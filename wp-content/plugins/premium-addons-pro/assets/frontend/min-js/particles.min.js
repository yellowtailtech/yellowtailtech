!function (t) { async function e(e) { var i, s, o, n, a, r = e, c = r.data("id"), l = r.find("#premium-particles-" + c), h = {}; if (!(h = elementorFrontend.isEditMode() && l.length > 0 ? (o = (s = l).data("particles-style"), n = s.data("particles-zindex"), a = s.data("particles-devices"), !!o && (h.zindex = n, h.style = o, h.devices = a.split(" "), 0 !== Object.keys(h).length ? h : void 0)) : !!(i = r.data()).particlesStyle && (h.zindex = i.particlesZindex, h.style = i.particlesStyle, h.devices = i.particlesDevices.split(" "), 0 !== Object.keys(h).length ? h : void 0))) return !1; var d = elementorFrontend.getCurrentDeviceMode(); -1 === h.devices.indexOf(d) && -1 !== ["desktop", "mobile", "tablet"].indexOf(d) || (r.attr("id", "premium-section-particles-" + c), await loadFull(tsParticles), t("#premium-section-particles-" + c).particles().init(h.style), r.children("canvas").css({ zIndex: h.zindex })) } !function (t, e) { if ("object" == typeof exports && "object" == typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { var i = e(); for (var s in i) ("object" == typeof exports ? exports : t)[s] = i[s] } }(this, (() => (() => { var t = { d: (e, i) => { for (var s in i) t.o(i, s) && !t.o(e, s) && Object.defineProperty(e, s, { enumerable: !0, get: i[s] }) }, o: (t, e) => Object.prototype.hasOwnProperty.call(t, e), r: t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) } }, e = {}; t.r(e), t.d(e, { AlterType: () => Ut, AnimatableColor: () => li, AnimationMode: () => st, AnimationOptions: () => ni, AnimationStatus: () => ot, AnimationValueWithRandom: () => pi, Background: () => We, BackgroundMask: () => $e, BackgroundMaskCover: () => je, BaseRange: () => Yi, Circle: () => Ji, ClickEvent: () => Ne, CollisionMode: () => Ae, Collisions: () => yi, CollisionsAbsorb: () => hi, CollisionsOverlap: () => di, ColorAnimation: () => ri, DestroyType: () => nt, DivEvent: () => Qe, DivType: () => Ee, EasingType: () => gs, EventType: () => Te, Events: () => Je, ExternalInteractorBase: () => xs, FullScreen: () => Ge, GradientType: () => ys, HoverEvent: () => Xe, HslAnimation: () => ci, HslColorManager: () => bs, Interactivity: () => ti, InteractivityDetect: () => De, InteractorType: () => Be, LimitMode: () => Le, ManualParticle: () => ei, Modes: () => Ke, Move: () => Oi, MoveAngle: () => bi, MoveAttract: () => wi, MoveCenter: () => xi, MoveDirection: () => g, MoveGravity: () => _i, MovePath: () => ki, MoveTrail: () => zi, Opacity: () => Di, OpacityAnimation: () => Si, Options: () => Wi, OptionsColor: () => Ve, OutMode: () => Fe, OutModeDirection: () => at, OutModes: () => Ci, Parallax: () => Ze, ParticleOutType: () => qe, ParticlesBounce: () => vi, ParticlesBounceFactor: () => mi, ParticlesDensity: () => Ti, ParticlesInteractorBase: () => _s, ParticlesNumber: () => Ri, ParticlesNumberLimit: () => Ei, ParticlesOptions: () => Hi, PixelMode: () => rt, Point: () => Zi, RangedAnimationOptions: () => ai, RangedAnimationValueWithRandom: () => fi, Rectangle: () => Ki, ResizeEvent: () => Ye, Responsive: () => ii, ResponsiveMode: () => Re, RgbColorManager: () => ws, RotateDirection: () => vs, Shadow: () => Ii, Shape: () => Ai, Size: () => Li, SizeAnimation: () => Fi, Spin: () => Mi, StartValueType: () => ct, Stroke: () => Bi, Theme: () => oi, ThemeDefault: () => si, ThemeMode: () => Ie, ValueWithRandom: () => ui, Vector: () => C, Vector3d: () => z, ZIndex: () => qi, addColorManager: () => Gt, addEasing: () => T, alterHsl: () => Ce, animate: () => F, areBoundsInside: () => kt, arrayRandomIndex: () => wt, calcExactPositionOrRandomFromSize: () => tt, calcExactPositionOrRandomFromSizeRanged: () => et, calcPositionFromSize: () => Y, calcPositionOrRandomFromSize: () => J, calcPositionOrRandomFromSizeRanged: () => K, calculateBounds: () => Pt, cancelAnimation: () => L, circleBounce: () => Tt, circleBounceDataFromParticle: () => Dt, clamp: () => B, clear: () => be, collisionVelocity: () => X, colorMix: () => ae, colorToHsl: () => Xt, colorToRgb: () => Zt, deepExtend: () => zt, degToRad: () => N, divMode: () => St, divModeExecute: () => Mt, drawEffect: () => xe, drawLine: () => ve, drawParticle: () => we, drawParticlePlugin: () => ze, drawPlugin: () => Pe, drawShape: () => _e, drawShapeAfterDraw: () => ke, errorPrefix: () => f, executeOnSingleOrMultiple: () => Rt, findItemFromSingleOrMultiple: () => At, generatedAttribute: () => i, getDistance: () => G, getDistances: () => $, getEasing: () => E, getHslAnimationFromHsl: () => he, getHslFromAnimation: () => le, getLinkColor: () => re, getLinkRandomColor: () => ce, getLogger: () => dt, getParticleBaseVelocity: () => Z, getParticleDirectionAngle: () => Q, getPosition: () => Bt, getRandom: () => I, getRandomRgbColor: () => se, getRangeMax: () => W, getRangeMin: () => V, getRangeValue: () => U, getSize: () => qt, getStyleFromHsl: () => ne, getStyleFromRgb: () => oe, halfRandom: () => v, hasMatchMedia: () => ft, hslToRgb: () => ee, hslaToRgba: () => ie, initParticleNumericAnimationValue: () => Ft, isArray: () => P, isBoolean: () => b, isDivModeEnabled: () => Ct, isFunction: () => _, isInArray: () => gt, isNumber: () => x, isObject: () => k, isPointInside: () => _t, isSsr: () => pt, isString: () => w, itemFromArray: () => xt, itemFromSingleOrMultiple: () => It, loadFont: () => bt, loadFull: () => Da, loadOptions: () => Ui, loadParticlesOptions: () => Vi, millisecondsToSeconds: () => y, mix: () => q, mouseDownEvent: () => s, mouseLeaveEvent: () => n, mouseMoveEvent: () => r, mouseOutEvent: () => a, mouseUpEvent: () => o, paintBase: () => ye, paintImage: () => ge, parseAlpha: () => it, percentDenominator: () => m, randomInRange: () => H, rangeColorToHsl: () => Yt, rangeColorToRgb: () => Qt, rectBounce: () => Et, resizeEvent: () => u, rgbToHsl: () => Jt, safeIntersectionObserver: () => vt, safeMatchMedia: () => mt, safeMutationObserver: () => yt, setAnimationFunctions: () => A, setLogger: () => ht, setRandom: () => R, setRangeValue: () => j, singleDivModeExecute: () => Ot, stringToAlpha: () => Kt, stringToRgb: () => te, touchCancelEvent: () => d, touchEndEvent: () => l, touchMoveEvent: () => h, touchStartEvent: () => c, tsParticles: () => ks, updateAnimation: () => Ht, updateColor: () => pe, updateColorValue: () => ue, visibilityChangeEvent: () => p }); const i = "generated", s = "pointerdown", o = "pointerup", n = "pointerleave", a = "pointerout", r = "pointermove", c = "touchstart", l = "touchend", h = "touchmove", d = "touchcancel", u = "resize", p = "visibilitychange", f = "tsParticles - Error", m = 100, v = .5, y = 1e3; var g; function b(t) { return "boolean" == typeof t } function w(t) { return "string" == typeof t } function x(t) { return "number" == typeof t } function _(t) { return "function" == typeof t } function k(t) { return "object" == typeof t && null !== t } function P(t) { return Array.isArray(t) } !function (t) { t.bottom = "bottom", t.bottomLeft = "bottom-left", t.bottomRight = "bottom-right", t.left = "left", t.none = "none", t.right = "right", t.top = "top", t.topLeft = "top-left", t.topRight = "top-right", t.outside = "outside", t.inside = "inside" }(g || (g = {})); class z { constructor(t, e, i) { if (this._updateFromAngle = (t, e) => { this.x = Math.cos(t) * e, this.y = Math.sin(t) * e }, !x(t) && t) { this.x = t.x, this.y = t.y; const e = t; this.z = e.z ? e.z : 0 } else { if (void 0 === t || void 0 === e) throw new Error(`${f} Vector3d not initialized correctly`); this.x = t, this.y = e, this.z = i ?? 0 } } static get origin() { return z.create(0, 0, 0) } get angle() { return Math.atan2(this.y, this.x) } set angle(t) { this._updateFromAngle(t, this.length) } get length() { return Math.sqrt(this.getLengthSq()) } set length(t) { this._updateFromAngle(this.angle, t) } static clone(t) { return z.create(t.x, t.y, t.z) } static create(t, e, i) { return new z(t, e, i) } add(t) { return z.create(this.x + t.x, this.y + t.y, this.z + t.z) } addTo(t) { this.x += t.x, this.y += t.y, this.z += t.z } copy() { return z.clone(this) } distanceTo(t) { return this.sub(t).length } distanceToSq(t) { return this.sub(t).getLengthSq() } div(t) { return z.create(this.x / t, this.y / t, this.z / t) } divTo(t) { this.x /= t, this.y /= t, this.z /= t } getLengthSq() { return this.x ** 2 + this.y ** 2 } mult(t) { return z.create(this.x * t, this.y * t, this.z * t) } multTo(t) { this.x *= t, this.y *= t, this.z *= t } normalize() { const t = this.length; 0 != t && this.multTo(1 / t) } rotate(t) { return z.create(this.x * Math.cos(t) - this.y * Math.sin(t), this.x * Math.sin(t) + this.y * Math.cos(t), 0) } setTo(t) { this.x = t.x, this.y = t.y; const e = t; this.z = e.z ? e.z : 0 } sub(t) { return z.create(this.x - t.x, this.y - t.y, this.z - t.z) } subFrom(t) { this.x -= t.x, this.y -= t.y, this.z -= t.z } } class C extends z { constructor(t, e) { super(t, e, 0) } static get origin() { return C.create(0, 0) } static clone(t) { return C.create(t.x, t.y) } static create(t, e) { return new C(t, e) } } let M = Math.random; const O = { nextFrame: t => requestAnimationFrame(t), cancel: t => cancelAnimationFrame(t) }, S = new Map, D = 2 * Math.PI; function T(t, e) { S.get(t) || S.set(t, e) } function E(t) { return S.get(t) ?? (t => t) } function R(t = Math.random) { M = t } function I() { return B(M(), 0, 1 - Number.EPSILON) } function A(t, e) { O.nextFrame = e => t(e), O.cancel = t => e(t) } function F(t) { return O.nextFrame(t) } function L(t) { O.cancel(t) } function B(t, e, i) { return Math.min(Math.max(t, e), i) } function q(t, e, i, s) { return Math.floor((t * i + e * s) / (i + s)) } function H(t) { const e = W(t); let i = V(t); return e === i && (i = 0), I() * (e - i) + i } function U(t) { return x(t) ? t : H(t) } function V(t) { return x(t) ? t : t.min } function W(t) { return x(t) ? t : t.max } function j(t, e) { if (t === e || void 0 === e && x(t)) return t; const i = V(t), s = W(t); return void 0 !== e ? { min: Math.min(i, e), max: Math.max(s, e) } : j(i, s) } function $(t, e) { const i = t.x - e.x, s = t.y - e.y; return { dx: i, dy: s, distance: Math.sqrt(i ** 2 + s ** 2) } } function G(t, e) { return $(t, e).distance } function N(t) { return t * Math.PI / 180 } function Q(t, e, i) { if (x(t)) return N(t); switch (t) { case g.top: return .5 * -Math.PI; case g.topRight: return .25 * -Math.PI; case g.right: return 0; case g.bottomRight: return .25 * Math.PI; case g.bottom: return .5 * Math.PI; case g.bottomLeft: return .75 * Math.PI; case g.left: return Math.PI; case g.topLeft: return .75 * -Math.PI; case g.inside: return Math.atan2(i.y - e.y, i.x - e.x); case g.outside: return Math.atan2(e.y - i.y, e.x - i.x); default: return I() * D } } function Z(t) { const e = C.origin; return e.length = 1, e.angle = t, e } function X(t, e, i, s) { return C.create(t.x * (i - s) / (i + s) + 2 * e.x * s / (i + s), t.y) } function Y(t) { return void 0 !== t.position?.x && void 0 !== t.position.y ? { x: t.position.x * t.size.width / m, y: t.position.y * t.size.height / m } : void 0 } function J(t) { return { x: (t.position?.x ?? I() * m) * t.size.width / m, y: (t.position?.y ?? I() * m) * t.size.height / m } } function K(t) { const e = { x: void 0 !== t.position?.x ? U(t.position.x) : void 0, y: void 0 !== t.position?.y ? U(t.position.y) : void 0 }; return J({ size: t.size, position: e }) } function tt(t) { return { x: t.position?.x ?? I() * t.size.width, y: t.position?.y ?? I() * t.size.height } } function et(t) { const e = { x: void 0 !== t.position?.x ? U(t.position.x) : void 0, y: void 0 !== t.position?.y ? U(t.position.y) : void 0 }; return tt({ size: t.size, position: e }) } function it(t) { return t ? t.endsWith("%") ? parseFloat(t) / m : parseFloat(t) : 1 } var st, ot, nt, at, rt, ct; !function (t) { t.auto = "auto", t.increase = "increase", t.decrease = "decrease", t.random = "random" }(st || (st = {})), function (t) { t.increasing = "increasing", t.decreasing = "decreasing" }(ot || (ot = {})), function (t) { t.none = "none", t.max = "max", t.min = "min" }(nt || (nt = {})), function (t) { t.bottom = "bottom", t.left = "left", t.right = "right", t.top = "top" }(at || (at = {})), function (t) { t.precise = "precise", t.percent = "percent" }(rt || (rt = {})), function (t) { t.max = "max", t.min = "min", t.random = "random" }(ct || (ct = {})); const lt = { debug: console.debug, error: console.error, info: console.info, log: console.log, verbose: console.log, warning: console.warn }; function ht(t) { lt.debug = t.debug || lt.debug, lt.error = t.error || lt.error, lt.info = t.info || lt.info, lt.log = t.log || lt.log, lt.verbose = t.verbose || lt.verbose, lt.warning = t.warning || lt.warning } function dt() { return lt } function ut(t) { const e = { bounced: !1 }, { pSide: i, pOtherSide: s, rectSide: o, rectOtherSide: n, velocity: a, factor: r } = t; return s.min < n.min || s.min > n.max || s.max < n.min || s.max > n.max || (i.max >= o.min && i.max <= .5 * (o.max + o.min) && a > 0 || i.min <= o.max && i.min > .5 * (o.max + o.min) && a < 0) && (e.velocity = a * -r, e.bounced = !0), e } function pt() { return "undefined" == typeof window || !window || void 0 === window.document || !window.document } function ft() { return !pt() && "undefined" != typeof matchMedia } function mt(t) { if (ft()) return matchMedia(t) } function vt(t) { if (!pt() && "undefined" != typeof IntersectionObserver) return new IntersectionObserver(t) } function yt(t) { if (!pt() && "undefined" != typeof MutationObserver) return new MutationObserver(t) } function gt(t, e) { return t === e || P(e) && e.indexOf(t) > -1 } async function bt(t, e) { try { await document.fonts.load(`${e ?? "400"} 36px '${t ?? "Verdana"}'`) } catch { } } function wt(t) { return Math.floor(I() * t.length) } function xt(t, e, i = !0) { return t[void 0 !== e && i ? e % t.length : wt(t)] } function _t(t, e, i, s, o) { return kt(Pt(t, s ?? 0), e, i, o) } function kt(t, e, i, s) { let o = !0; return s && s !== at.bottom || (o = t.top < e.height + i.x), !o || s && s !== at.left || (o = t.right > i.x), !o || s && s !== at.right || (o = t.left < e.width + i.y), !o || s && s !== at.top || (o = t.bottom > i.y), o } function Pt(t, e) { return { bottom: t.y + e, left: t.x - e, right: t.x + e, top: t.y - e } } function zt(t, ...e) { for (const i of e) { if (null == i) continue; if (!k(i)) { t = i; continue } const e = Array.isArray(i); !e || !k(t) && t && Array.isArray(t) ? e || !k(t) && t && !Array.isArray(t) || (t = {}) : t = []; for (const e in i) { if ("__proto__" === e) continue; const s = i[e], o = t; o[e] = k(s) && Array.isArray(s) ? s.map((t => zt(o[e], t))) : zt(o[e], s) } } return t } function Ct(t, e) { return !!At(e, (e => e.enable && gt(t, e.mode))) } function Mt(t, e, i) { Rt(e, (e => { const s = e.mode; e.enable && gt(t, s) && Ot(e, i) })) } function Ot(t, e) { Rt(t.selectors, (i => { e(i, t) })) } function St(t, e) { if (e && t) return At(t, (t => function (t, e) { const i = Rt(e, (e => t.matches(e))); return P(i) ? i.some((t => t)) : i }(e, t.selectors))) } function Dt(t) { return { position: t.getPosition(), radius: t.getRadius(), mass: t.getMass(), velocity: t.velocity, factor: C.create(U(t.options.bounce.horizontal.value), U(t.options.bounce.vertical.value)) } } function Tt(t, e) { const { x: i, y: s } = t.velocity.sub(e.velocity), [o, n] = [t.position, e.position], { dx: a, dy: r } = $(n, o); if (i * a + s * r < 0) return; const c = -Math.atan2(r, a), l = t.mass, h = e.mass, d = t.velocity.rotate(c), u = e.velocity.rotate(c), p = X(d, u, l, h), f = X(u, d, l, h), m = p.rotate(-c), v = f.rotate(-c); t.velocity.x = m.x * t.factor.x, t.velocity.y = m.y * t.factor.y, e.velocity.x = v.x * e.factor.x, e.velocity.y = v.y * e.factor.y } function Et(t, e) { const i = Pt(t.getPosition(), t.getRadius()), s = t.options.bounce, o = ut({ pSide: { min: i.left, max: i.right }, pOtherSide: { min: i.top, max: i.bottom }, rectSide: { min: e.left, max: e.right }, rectOtherSide: { min: e.top, max: e.bottom }, velocity: t.velocity.x, factor: U(s.horizontal.value) }); o.bounced && (void 0 !== o.velocity && (t.velocity.x = o.velocity), void 0 !== o.position && (t.position.x = o.position)); const n = ut({ pSide: { min: i.top, max: i.bottom }, pOtherSide: { min: i.left, max: i.right }, rectSide: { min: e.top, max: e.bottom }, rectOtherSide: { min: e.left, max: e.right }, velocity: t.velocity.y, factor: U(s.vertical.value) }); n.bounced && (void 0 !== n.velocity && (t.velocity.y = n.velocity), void 0 !== n.position && (t.position.y = n.position)) } function Rt(t, e) { return P(t) ? t.map(((t, i) => e(t, i))) : e(t, 0) } function It(t, e, i) { return P(t) ? xt(t, e, i) : t } function At(t, e) { return P(t) ? t.find(((t, i) => e(t, i))) : e(t, 0) ? t : void 0 } function Ft(t, e) { const i = t.value, s = t.animation, o = { delayTime: U(s.delay) * y, enable: s.enable, value: U(t.value) * e, max: W(i) * e, min: V(i) * e, loops: 0, maxLoops: U(s.count), time: 0 }; if (s.enable) { switch (o.decay = 1 - U(s.decay), s.mode) { case st.increase: o.status = ot.increasing; break; case st.decrease: o.status = ot.decreasing; break; case st.random: o.status = I() >= v ? ot.increasing : ot.decreasing }const t = s.mode === st.auto; switch (s.startValue) { case ct.min: o.value = o.min, t && (o.status = ot.increasing); break; case ct.max: o.value = o.max, t && (o.status = ot.decreasing); break; case ct.random: default: o.value = H(o), t && (o.status = I() >= v ? ot.increasing : ot.decreasing) } } return o.initialValue = o.value, o } function Lt(t, e) { if (t.mode !== rt.percent) { const { mode: e, ...i } = t; return i } return "x" in t ? { x: t.x / m * e.width, y: t.y / m * e.height } : { width: t.width / m * e.width, height: t.height / m * e.height } } function Bt(t, e) { return Lt(t, e) } function qt(t, e) { return Lt(t, e) } function Ht(t, e, i, s, o) { if (t.destroyed || !e || !e.enable || (e.maxLoops ?? 0) > 0 && (e.loops ?? 0) > (e.maxLoops ?? 0)) return; const n = (e.velocity ?? 0) * o.factor, a = e.min, r = e.max, c = e.decay ?? 1; if (e.time || (e.time = 0), (e.delayTime ?? 0) > 0 && e.time < (e.delayTime ?? 0) && (e.time += o.value), !((e.delayTime ?? 0) > 0 && e.time < (e.delayTime ?? 0))) { switch (e.status) { case ot.increasing: e.value >= r ? (i ? e.status = ot.decreasing : e.value -= r, e.loops || (e.loops = 0), e.loops++) : e.value += n; break; case ot.decreasing: e.value <= a ? (i ? e.status = ot.increasing : e.value += r, e.loops || (e.loops = 0), e.loops++) : e.value -= n }e.velocity && 1 !== c && (e.velocity *= c), function (t, e, i, s, o) { switch (e) { case nt.max: i >= o && t.destroy(); break; case nt.min: i <= s && t.destroy() } }(t, s, e.value, a, r), t.destroyed || (e.value = B(e.value, a, r)) } } var Ut, Vt; !function (t) { t.darken = "darken", t.enlighten = "enlighten" }(Ut || (Ut = {})), function (t) { t[t.r = 1] = "r", t[t.g = 2] = "g", t[t.b = 3] = "b", t[t.a = 4] = "a" }(Vt || (Vt = {})); const Wt = "random", jt = "mid", $t = new Map; function Gt(t) { $t.set(t.key, t) } function Nt(t) { for (const [, e] of $t) if (t.startsWith(e.stringPrefix)) return e.parseString(t); const e = t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, ((t, e, i, s, o) => e + e + i + i + s + s + (void 0 !== o ? o + o : ""))), i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(e); return i ? { a: void 0 !== i[Vt.a] ? parseInt(i[Vt.a], 16) / 255 : 1, b: parseInt(i[Vt.b], 16), g: parseInt(i[Vt.g], 16), r: parseInt(i[Vt.r], 16) } : void 0 } function Qt(t, e, i = !0) { if (!t) return; const s = w(t) ? { value: t } : t; if (w(s.value)) return Zt(s.value, e, i); if (P(s.value)) return Qt({ value: xt(s.value, e, i) }); for (const [, t] of $t) { const e = t.handleRangeColor(s); if (e) return e } } function Zt(t, e, i = !0) { if (!t) return; const s = w(t) ? { value: t } : t; if (w(s.value)) return s.value === Wt ? se() : te(s.value); if (P(s.value)) return Zt({ value: xt(s.value, e, i) }); for (const [, t] of $t) { const e = t.handleColor(s); if (e) return e } } function Xt(t, e, i = !0) { const s = Zt(t, e, i); return s ? Jt(s) : void 0 } function Yt(t, e, i = !0) { const s = Qt(t, e, i); return s ? Jt(s) : void 0 } function Jt(t) { const e = t.r / 255, i = t.g / 255, s = t.b / 255, o = Math.max(e, i, s), n = Math.min(e, i, s), a = { h: 0, l: .5 * (o + n), s: 0 }; return o !== n && (a.s = a.l < .5 ? (o - n) / (o + n) : (o - n) / (2 - o - n), a.h = e === o ? (i - s) / (o - n) : a.h = i === o ? 2 + (s - e) / (o - n) : 4 + (e - i) / (o - n)), a.l *= 100, a.s *= 100, a.h *= 60, a.h < 0 && (a.h += 360), a.h >= 360 && (a.h -= 360), a } function Kt(t) { return Nt(t)?.a } function te(t) { return Nt(t) } function ee(t) { const e = 360, i = (t.h % e + e) % e, s = Math.max(0, Math.min(100, t.s)), o = i / e, n = s / 100, a = Math.max(0, Math.min(100, t.l)) / 100, r = 255; if (0 === s) { const t = Math.round(a * r); return { r: t, g: t, b: t } } const c = (t, e, i) => (i < 0 && i++, i > 1 && i--, 6 * i < 1 ? t + 6 * (e - t) * i : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t), l = a < .5 ? a * (1 + n) : a + n - a * n, h = 2 * a - l, d = 1 / 3, u = Math.min(r, r * c(h, l, o + d)), p = Math.min(r, r * c(h, l, o)), f = Math.min(r, r * c(h, l, o - d)); return { r: Math.round(u), g: Math.round(p), b: Math.round(f) } } function ie(t) { const e = ee(t); return { a: t.a, b: e.b, g: e.g, r: e.r } } function se(t) { const e = t ?? 0; return { b: Math.floor(H(j(e, 256))), g: Math.floor(H(j(e, 256))), r: Math.floor(H(j(e, 256))) } } function oe(t, e) { return `rgba(${t.r}, ${t.g}, ${t.b}, ${e ?? 1})` } function ne(t, e) { return `hsla(${t.h}, ${t.s}%, ${t.l}%, ${e ?? 1})` } function ae(t, e, i, s) { let o = t, n = e; return void 0 === o.r && (o = ee(t)), void 0 === n.r && (n = ee(e)), { b: q(o.b, n.b, i, s), g: q(o.g, n.g, i, s), r: q(o.r, n.r, i, s) } } function re(t, e, i) { if (i === Wt) return se(); if (i !== jt) return i; { const i = t.getFillColor() ?? t.getStrokeColor(), s = e?.getFillColor() ?? e?.getStrokeColor(); if (i && s && e) return ae(i, s, t.getRadius(), e.getRadius()); { const t = i ?? s; if (t) return ee(t) } } } function ce(t, e, i) { const s = w(t) ? t : t.value; return s === Wt ? i ? Qt({ value: s }) : e ? Wt : jt : s === jt ? jt : Qt({ value: s }) } function le(t) { return void 0 !== t ? { h: t.h.value, s: t.s.value, l: t.l.value } : void 0 } function he(t, e, i) { const s = { h: { enable: !1, value: t.h }, s: { enable: !1, value: t.s }, l: { enable: !1, value: t.l } }; return e && (de(s.h, e.h, i), de(s.s, e.s, i), de(s.l, e.l, i)), s } function de(t, e, i) { t.enable = e.enable, t.enable ? (t.velocity = U(e.speed) / m * i, t.decay = 1 - U(e.decay), t.status = ot.increasing, t.loops = 0, t.maxLoops = U(e.count), t.time = 0, t.delayTime = U(e.delay) * y, e.sync || (t.velocity *= I(), t.value *= I()), t.initialValue = t.value, t.offset = j(e.offset)) : t.velocity = 0 } function ue(t, e, i, s) { if (!t || !t.enable || (t.maxLoops ?? 0) > 0 && (t.loops ?? 0) > (t.maxLoops ?? 0)) return; if (t.time || (t.time = 0), (t.delayTime ?? 0) > 0 && t.time < (t.delayTime ?? 0) && (t.time += s.value), (t.delayTime ?? 0) > 0 && t.time < (t.delayTime ?? 0)) return; const o = t.offset ? H(t.offset) : 0, n = (t.velocity ?? 0) * s.factor + 3.6 * o, a = t.decay ?? 1, r = W(e), c = V(e); if (i && t.status !== ot.increasing) { t.value -= n; const e = 0; t.value < e && (t.loops || (t.loops = 0), t.loops++, t.status = ot.increasing) } else t.value += n, t.value > r && (t.loops || (t.loops = 0), t.loops++, i ? t.status = ot.decreasing : t.value -= r); t.velocity && 1 !== a && (t.velocity *= a), t.value = B(t.value, c, r) } function pe(t, e) { if (!t) return; const { h: i, s: s, l: o } = t; i && ue(i, { min: 0, max: 360 }, !1, e), s && ue(s, { min: 0, max: 100 }, !0, e), o && ue(o, { min: 0, max: 100 }, !0, e) } const fe = { x: 0, y: 0 }, me = { a: 1, b: 0, c: 0, d: 1 }; function ve(t, e, i) { t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(i.x, i.y), t.closePath() } function ye(t, e, i) { t.fillStyle = i ?? "rgba(0,0,0,0)", t.fillRect(fe.x, fe.y, e.width, e.height) } function ge(t, e, i, s) { i && (t.globalAlpha = s, t.drawImage(i, fe.x, fe.y, e.width, e.height), t.globalAlpha = 1) } function be(t, e) { t.clearRect(fe.x, fe.y, e.width, e.height) } function we(t) { const { container: e, context: i, particle: s, delta: o, colorStyles: n, backgroundMask: a, composite: r, radius: c, opacity: l, shadow: h, transform: d } = t, u = s.getPosition(), p = s.rotation + (s.pathRotation ? s.velocity.angle : 0), f = Math.sin(p), m = Math.cos(p), v = !!p, y = { a: m * (d.a ?? me.a), b: v ? f * (d.b ?? 1) : d.b ?? me.b, c: v ? -f * (d.c ?? 1) : d.c ?? me.c, d: m * (d.d ?? me.d) }; i.setTransform(y.a, y.b, y.c, y.d, u.x, u.y), a && (i.globalCompositeOperation = r); const g = s.shadowColor; h.enable && g && (i.shadowBlur = h.blur, i.shadowColor = oe(g), i.shadowOffsetX = h.offset.x, i.shadowOffsetY = h.offset.y), n.fill && (i.fillStyle = n.fill); const b = s.strokeWidth ?? 0; i.lineWidth = b, n.stroke && (i.strokeStyle = n.stroke); const w = { container: e, context: i, particle: s, radius: c, opacity: l, delta: o, transformData: y, strokeWidth: b }; _e(w), ke(w), xe(w), i.globalCompositeOperation = "source-over", i.resetTransform() } function xe(t) { const { container: e, context: i, particle: s, radius: o, opacity: n, delta: a, transformData: r } = t; if (!s.effect) return; const c = e.effectDrawers.get(s.effect); c && c.draw({ context: i, particle: s, radius: o, opacity: n, delta: a, pixelRatio: e.retina.pixelRatio, transformData: { ...r } }) } function _e(t) { const { container: e, context: i, particle: s, radius: o, opacity: n, delta: a, strokeWidth: r, transformData: c } = t; if (!s.shape) return; const l = e.shapeDrawers.get(s.shape); l && (i.beginPath(), l.draw({ context: i, particle: s, radius: o, opacity: n, delta: a, pixelRatio: e.retina.pixelRatio, transformData: { ...c } }), s.shapeClose && i.closePath(), r > 0 && i.stroke(), s.shapeFill && i.fill()) } function ke(t) { const { container: e, context: i, particle: s, radius: o, opacity: n, delta: a, transformData: r } = t; if (!s.shape) return; const c = e.shapeDrawers.get(s.shape); c?.afterDraw && c.afterDraw({ context: i, particle: s, radius: o, opacity: n, delta: a, pixelRatio: e.retina.pixelRatio, transformData: { ...r } }) } function Pe(t, e, i) { e.draw && e.draw(t, i) } function ze(t, e, i, s) { e.drawParticle && e.drawParticle(t, i, s) } function Ce(t, e, i) { return { h: t.h, s: t.s, l: t.l + (e === Ut.darken ? -1 : 1) * i } } function Me(t, e, i) { const s = e[i]; void 0 !== s && (t[i] = (t[i] ?? 1) * s) } function Oe(t, e, i = !1) { if (!e) return; if (!t) return; const s = t.style; if (s) for (const t in e) { const i = e[t]; i && s.setProperty(t, i, "") } } class Se { constructor(t) { this.container = t, this._applyPostDrawUpdaters = t => { for (const e of this._postDrawUpdaters) e.afterDraw?.(t) }, this._applyPreDrawUpdaters = (t, e, i, s, o, n) => { for (const a of this._preDrawUpdaters) { if (a.getColorStyles) { const { fill: n, stroke: r } = a.getColorStyles(e, t, i, s); n && (o.fill = n), r && (o.stroke = r) } if (a.getTransformValues) { const t = a.getTransformValues(e); for (const e in t) Me(n, t, e) } a.beforeDraw?.(e) } }, this._applyResizePlugins = () => { for (const t of this._resizePlugins) t.resize?.() }, this._getPluginParticleColors = t => { let e, i; for (const s of this._colorPlugins) if (!e && s.particleFillColor && (e = Yt(s.particleFillColor(t))), !i && s.particleStrokeColor && (i = Yt(s.particleStrokeColor(t))), e && i) break; return [e, i] }, this._initCover = async () => { const t = this.container.actualOptions.backgroundMask.cover, e = t.color; if (e) { const i = Qt(e); if (i) { const e = { ...i, a: t.opacity }; this._coverColorStyle = oe(e, e.a) } } else await new Promise(((e, i) => { if (!t.image) return; const s = document.createElement("img"); s.addEventListener("load", (() => { this._coverImage = { image: s, opacity: t.opacity }, e() })), s.addEventListener("error", (t => { i(t.error) })), s.src = t.image })) }, this._initStyle = () => { const t = this.element, e = this.container.actualOptions; if (t) { this._fullScreen ? (this._originalStyle = zt({}, t.style), this._setFullScreenStyle()) : this._resetOriginalStyle(); for (const i in e.style) { if (!i || !e.style) continue; const s = e.style[i]; s && t.style.setProperty(i, s, "") } } }, this._initTrail = async () => { const t = this.container.actualOptions.particles.move.trail, e = t.fill; if (!t.enable) return; const i = 1 / t.length; if (e.color) { const t = Qt(e.color); if (!t) return; this._trailFill = { color: { ...t }, opacity: i } } else await new Promise(((t, s) => { if (!e.image) return; const o = document.createElement("img"); o.addEventListener("load", (() => { this._trailFill = { image: o, opacity: i }, t() })), o.addEventListener("error", (t => { s(t.error) })), o.src = e.image })) }, this._paintBase = t => { this.draw((e => ye(e, this.size, t))) }, this._paintImage = (t, e) => { this.draw((i => ge(i, this.size, t, e))) }, this._repairStyle = () => { const t = this.element; t && (this._safeMutationObserver((t => t.disconnect())), this._initStyle(), this.initBackground(), this._safeMutationObserver((e => { t && t instanceof Node && e.observe(t, { attributes: !0 }) }))) }, this._resetOriginalStyle = () => { const t = this.element, e = this._originalStyle; t && e && Oe(t, e) }, this._safeMutationObserver = t => { this._mutationObserver && t(this._mutationObserver) }, this._setFullScreenStyle = () => { const t = this.element; t && Oe(t, { position: "absolute", zIndex: this.container.actualOptions.fullScreen.zIndex.toString(10), top: "0", left: "0", width: "100%", height: "100%" }, !0) }, this.size = { height: 0, width: 0 }, this._context = null, this._generated = !1, this._preDrawUpdaters = [], this._postDrawUpdaters = [], this._resizePlugins = [], this._colorPlugins = [] } get _fullScreen() { return this.container.actualOptions.fullScreen.enable } clear() { const t = this.container.actualOptions, e = t.particles.move.trail, i = this._trailFill; t.backgroundMask.enable ? this.paint() : e.enable && e.length > 0 && i ? i.color ? this._paintBase(oe(i.color, i.opacity)) : i.image && this._paintImage(i.image, i.opacity) : t.clear && this.draw((t => { be(t, this.size) })) } destroy() { if (this.stop(), this._generated) { const t = this.element; t?.remove() } else this._resetOriginalStyle(); this._preDrawUpdaters = [], this._postDrawUpdaters = [], this._resizePlugins = [], this._colorPlugins = [] } draw(t) { const e = this._context; if (e) return t(e) } drawAsync(t) { const e = this._context; if (e) return t(e) } drawParticle(t, e) { if (t.spawning || t.destroyed) return; const i = t.getRadius(); if (i <= 0) return; const s = t.getFillColor(), o = t.getStrokeColor() ?? s; let [n, a] = this._getPluginParticleColors(t); n || (n = s), a || (a = o), (n || a) && this.draw((s => { const o = this.container, r = o.actualOptions, c = t.options.zIndex, l = 1 - t.zIndexFactor, h = l ** c.opacityRate, d = t.bubble.opacity ?? t.opacity?.value ?? 1, u = d * h, p = (t.strokeOpacity ?? d) * h, f = {}, m = { fill: n ? ne(n, u) : void 0 }; m.stroke = a ? ne(a, p) : m.fill, this._applyPreDrawUpdaters(s, t, i, u, m, f), we({ container: o, context: s, particle: t, delta: e, colorStyles: m, backgroundMask: r.backgroundMask.enable, composite: r.backgroundMask.composite, radius: i * l ** c.sizeRate, opacity: u, shadow: t.options.shadow, transform: f }), this._applyPostDrawUpdaters(t) })) } drawParticlePlugin(t, e, i) { this.draw((s => ze(s, t, e, i))) } drawPlugin(t, e) { this.draw((i => Pe(i, t, e))) } async init() { this._safeMutationObserver((t => t.disconnect())), this._mutationObserver = yt((t => { for (const e of t) "attributes" === e.type && "style" === e.attributeName && this._repairStyle() })), this.resize(), this._initStyle(), await this._initCover(); try { await this._initTrail() } catch (t) { dt().error(t) } this.initBackground(), this._safeMutationObserver((t => { this.element && this.element instanceof Node && t.observe(this.element, { attributes: !0 }) })), this.initUpdaters(), this.initPlugins(), this.paint() } initBackground() { const t = this.container.actualOptions.background, e = this.element; if (!e) return; const i = e.style; if (i) { if (t.color) { const e = Qt(t.color); i.backgroundColor = e ? oe(e, t.opacity) : "" } else i.backgroundColor = ""; i.backgroundImage = t.image || "", i.backgroundPosition = t.position || "", i.backgroundRepeat = t.repeat || "", i.backgroundSize = t.size || "" } } initPlugins() { this._resizePlugins = []; for (const [, t] of this.container.plugins) t.resize && this._resizePlugins.push(t), (t.particleFillColor ?? t.particleStrokeColor) && this._colorPlugins.push(t) } initUpdaters() { this._preDrawUpdaters = [], this._postDrawUpdaters = []; for (const t of this.container.particles.updaters) t.afterDraw && this._postDrawUpdaters.push(t), (t.getColorStyles ?? t.getTransformValues ?? t.beforeDraw) && this._preDrawUpdaters.push(t) } loadCanvas(t) { this._generated && this.element && this.element.remove(), this._generated = t.dataset && i in t.dataset ? "true" === t.dataset[i] : this._generated, this.element = t, this.element.ariaHidden = "true", this._originalStyle = zt({}, this.element.style), this.size.height = t.offsetHeight, this.size.width = t.offsetWidth, this._context = this.element.getContext("2d"), this._safeMutationObserver((t => { this.element && this.element instanceof Node && t.observe(this.element, { attributes: !0 }) })), this.container.retina.init(), this.initBackground() } paint() { const t = this.container.actualOptions; this.draw((e => { t.backgroundMask.enable && t.backgroundMask.cover ? (be(e, this.size), this._coverImage ? this._paintImage(this._coverImage.image, this._coverImage.opacity) : this._coverColorStyle ? this._paintBase(this._coverColorStyle) : this._paintBase()) : this._paintBase() })) } resize() { if (!this.element) return !1; const t = this.container, e = t.retina.pixelRatio, i = t.canvas.size, s = this.element.offsetWidth * e, o = this.element.offsetHeight * e; if (o === i.height && s === i.width && o === this.element.height && s === this.element.width) return !1; const n = { ...i }; return this.element.width = i.width = this.element.offsetWidth * e, this.element.height = i.height = this.element.offsetHeight * e, this.container.started && t.particles.setResizeFactor({ width: i.width / n.width, height: i.height / n.height }), !0 } stop() { this._safeMutationObserver((t => t.disconnect())), this._mutationObserver = void 0, this.draw((t => be(t, this.size))) } async windowResize() { if (!this.element || !this.resize()) return; const t = this.container, e = t.updateActualOptions(); t.particles.setDensity(), this._applyResizePlugins(), e && await t.refresh() } } var De, Te, Ee, Re, Ie, Ae, Fe, Le, Be, qe; function He(t, e, i, s, o) { if (s) { let s = { passive: !0 }; b(o) ? s.capture = o : void 0 !== o && (s = o), t.addEventListener(e, i, s) } else { const s = o; t.removeEventListener(e, i, s) } } !function (t) { t.canvas = "canvas", t.parent = "parent", t.window = "window" }(De || (De = {})); class Ue { constructor(t) { this.container = t, this._doMouseTouchClick = t => { const e = this.container, i = e.actualOptions; if (this._canPush) { const t = e.interactivity.mouse, s = t.position; if (!s) return; t.clickPosition = { ...s }, t.clickTime = (new Date).getTime(), Rt(i.interactivity.events.onClick.mode, (t => this.container.handleClickMode(t))) } "touchend" === t.type && setTimeout((() => this._mouseTouchFinish()), 500) }, this._handleThemeChange = t => { const e = t, i = this.container, s = i.options, o = s.defaultThemes, n = e.matches ? o.dark : o.light, a = s.themes.find((t => t.name === n)); a?.default.auto && i.loadTheme(n) }, this._handleVisibilityChange = () => { const t = this.container, e = t.actualOptions; this._mouseTouchFinish(), e.pauseOnBlur && (document?.hidden ? (t.pageHidden = !0, t.pause()) : (t.pageHidden = !1, t.animationStatus ? t.play(!0) : t.draw(!0))) }, this._handleWindowResize = () => { this._resizeTimeout && (clearTimeout(this._resizeTimeout), delete this._resizeTimeout); const t = async () => { const t = this.container.canvas; await (t?.windowResize()) }; this._resizeTimeout = setTimeout((() => { t() }), this.container.actualOptions.interactivity.events.resize.delay * y) }, this._manageInteractivityListeners = (t, e) => { const i = this._handlers, n = this.container, a = n.actualOptions, u = n.interactivity.element; if (!u) return; const p = u, f = n.canvas.element; f && (f.style.pointerEvents = p === f ? "initial" : "none"), (a.interactivity.events.onHover.enable || a.interactivity.events.onClick.enable) && (He(u, r, i.mouseMove, e), He(u, c, i.touchStart, e), He(u, h, i.touchMove, e), a.interactivity.events.onClick.enable ? (He(u, l, i.touchEndClick, e), He(u, o, i.mouseUp, e), He(u, s, i.mouseDown, e)) : He(u, l, i.touchEnd, e), He(u, t, i.mouseLeave, e), He(u, d, i.touchCancel, e)) }, this._manageListeners = t => { const e = this._handlers, i = this.container, s = i.actualOptions.interactivity.detectsOn, o = i.canvas.element; let r = n; s === De.window ? (i.interactivity.element = window, r = a) : s === De.parent && o ? i.interactivity.element = o.parentElement ?? o.parentNode : i.interactivity.element = o, this._manageMediaMatch(t), this._manageResize(t), this._manageInteractivityListeners(r, t), document && He(document, p, e.visibilityChange, t, !1) }, this._manageMediaMatch = t => { const e = this._handlers, i = mt("(prefers-color-scheme: dark)"); i && (void 0 === i.addEventListener ? void 0 !== i.addListener && (t ? i.addListener(e.oldThemeChange) : i.removeListener(e.oldThemeChange)) : He(i, "change", e.themeChange, t)) }, this._manageResize = t => { const e = this._handlers, i = this.container; if (!i.actualOptions.interactivity.events.resize) return; if ("undefined" == typeof ResizeObserver) return void He(window, u, e.resize, t); const s = i.canvas.element; this._resizeObserver && !t ? (s && this._resizeObserver.unobserve(s), this._resizeObserver.disconnect(), delete this._resizeObserver) : !this._resizeObserver && t && s && (this._resizeObserver = new ResizeObserver((t => { t.find((t => t.target === s)) && this._handleWindowResize() })), this._resizeObserver.observe(s)) }, this._mouseDown = () => { const { interactivity: t } = this.container; if (!t) return; const { mouse: e } = t; e.clicking = !0, e.downPosition = e.position }, this._mouseTouchClick = t => { const e = this.container, i = e.actualOptions, { mouse: s } = e.interactivity; s.inside = !0; let o = !1; const n = s.position; if (n && i.interactivity.events.onClick.enable) { for (const [, t] of e.plugins) if (t.clickPositionValid && (o = t.clickPositionValid(n), o)) break; o || this._doMouseTouchClick(t), s.clicking = !1 } }, this._mouseTouchFinish = () => { const t = this.container.interactivity; if (!t) return; const e = t.mouse; delete e.position, delete e.clickPosition, delete e.downPosition, t.status = n, e.inside = !1, e.clicking = !1 }, this._mouseTouchMove = t => { const e = this.container, i = e.actualOptions, s = e.interactivity, o = e.canvas.element; if (!s?.element) return; let n; if (s.mouse.inside = !0, t.type.startsWith("pointer")) { this._canPush = !0; const e = t; if (s.element === window) { if (o) { const t = o.getBoundingClientRect(); n = { x: e.clientX - t.left, y: e.clientY - t.top } } } else if (i.interactivity.detectsOn === De.parent) { const t = e.target, i = e.currentTarget; if (t && i && o) { const s = t.getBoundingClientRect(), a = i.getBoundingClientRect(), r = o.getBoundingClientRect(); n = { x: e.offsetX + 2 * s.left - (a.left + r.left), y: e.offsetY + 2 * s.top - (a.top + r.top) } } else n = { x: e.offsetX ?? e.clientX, y: e.offsetY ?? e.clientY } } else e.target === o && (n = { x: e.offsetX ?? e.clientX, y: e.offsetY ?? e.clientY }) } else if (this._canPush = "touchmove" !== t.type, o) { const e = t, i = 1, s = e.touches[e.touches.length - i], a = o.getBoundingClientRect(), r = 0; n = { x: s.clientX - (a.left ?? r), y: s.clientY - (a.top ?? r) } } const a = e.retina.pixelRatio; n && (n.x *= a, n.y *= a), s.mouse.position = n, s.status = r }, this._touchEnd = t => { const e = t, i = Array.from(e.changedTouches); for (const t of i) this._touches.delete(t.identifier); this._mouseTouchFinish() }, this._touchEndClick = t => { const e = t, i = Array.from(e.changedTouches); for (const t of i) this._touches.delete(t.identifier); this._mouseTouchClick(t) }, this._touchStart = t => { const e = t, i = Array.from(e.changedTouches); for (const t of i) this._touches.set(t.identifier, performance.now()); this._mouseTouchMove(t) }, this._canPush = !0, this._touches = new Map, this._handlers = { mouseDown: () => this._mouseDown(), mouseLeave: () => this._mouseTouchFinish(), mouseMove: t => this._mouseTouchMove(t), mouseUp: t => this._mouseTouchClick(t), touchStart: t => this._touchStart(t), touchMove: t => this._mouseTouchMove(t), touchEnd: t => this._touchEnd(t), touchCancel: t => this._touchEnd(t), touchEndClick: t => this._touchEndClick(t), visibilityChange: () => this._handleVisibilityChange(), themeChange: t => this._handleThemeChange(t), oldThemeChange: t => this._handleThemeChange(t), resize: () => { this._handleWindowResize() } } } addListeners() { this._manageListeners(!0) } removeListeners() { this._manageListeners(!1) } } !function (t) { t.configAdded = "configAdded", t.containerInit = "containerInit", t.particlesSetup = "particlesSetup", t.containerStarted = "containerStarted", t.containerStopped = "containerStopped", t.containerDestroyed = "containerDestroyed", t.containerPaused = "containerPaused", t.containerPlay = "containerPlay", t.containerBuilt = "containerBuilt", t.particleAdded = "particleAdded", t.particleDestroyed = "particleDestroyed", t.particleRemoved = "particleRemoved" }(Te || (Te = {})); class Ve { constructor() { this.value = "" } static create(t, e) { const i = new Ve; return i.load(t), void 0 !== e && (w(e) || P(e) ? i.load({ value: e }) : i.load(e)), i } load(t) { void 0 !== t?.value && (this.value = t.value) } } class We { constructor() { this.color = new Ve, this.color.value = "", this.image = "", this.position = "", this.repeat = "", this.size = "", this.opacity = 1 } load(t) { t && (void 0 !== t.color && (this.color = Ve.create(this.color, t.color)), void 0 !== t.image && (this.image = t.image), void 0 !== t.position && (this.position = t.position), void 0 !== t.repeat && (this.repeat = t.repeat), void 0 !== t.size && (this.size = t.size), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class je { constructor() { this.opacity = 1 } load(t) { t && (void 0 !== t.color && (this.color = Ve.create(this.color, t.color)), void 0 !== t.image && (this.image = t.image), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class $e { constructor() { this.composite = "destination-out", this.cover = new je, this.enable = !1 } load(t) { if (t) { if (void 0 !== t.composite && (this.composite = t.composite), void 0 !== t.cover) { const e = t.cover, i = w(t.cover) ? { color: t.cover } : t.cover; this.cover.load(void 0 !== e.color || void 0 !== e.image ? e : { color: i }) } void 0 !== t.enable && (this.enable = t.enable) } } } class Ge { constructor() { this.enable = !0, this.zIndex = 0 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.zIndex && (this.zIndex = t.zIndex)) } } class Ne { constructor() { this.enable = !1, this.mode = [] } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode)) } } !function (t) { t.circle = "circle", t.rectangle = "rectangle" }(Ee || (Ee = {})); class Qe { constructor() { this.selectors = [], this.enable = !1, this.mode = [], this.type = Ee.circle } load(t) { t && (void 0 !== t.selectors && (this.selectors = t.selectors), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.type && (this.type = t.type)) } } class Ze { constructor() { this.enable = !1, this.force = 2, this.smooth = 10 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.force && (this.force = t.force), void 0 !== t.smooth && (this.smooth = t.smooth)) } } class Xe { constructor() { this.enable = !1, this.mode = [], this.parallax = new Ze } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.mode && (this.mode = t.mode), this.parallax.load(t.parallax)) } } class Ye { constructor() { this.delay = .5, this.enable = !0 } load(t) { void 0 !== t && (void 0 !== t.delay && (this.delay = t.delay), void 0 !== t.enable && (this.enable = t.enable)) } } class Je { constructor() { this.onClick = new Ne, this.onDiv = new Qe, this.onHover = new Xe, this.resize = new Ye } load(t) { if (!t) return; this.onClick.load(t.onClick); const e = t.onDiv; void 0 !== e && (this.onDiv = Rt(e, (t => { const e = new Qe; return e.load(t), e }))), this.onHover.load(t.onHover), this.resize.load(t.resize) } } class Ke { constructor(t, e) { this._engine = t, this._container = e } load(t) { if (!t) return; if (!this._container) return; const e = this._engine.interactors.get(this._container); if (e) for (const i of e) i.loadModeOptions && i.loadModeOptions(this, t) } } class ti { constructor(t, e) { this.detectsOn = De.window, this.events = new Je, this.modes = new Ke(t, e) } load(t) { if (!t) return; const e = t.detectsOn; void 0 !== e && (this.detectsOn = e), this.events.load(t.events), this.modes.load(t.modes) } } class ei { load(t) { t && (t.position && (this.position = { x: t.position.x ?? 50, y: t.position.y ?? 50, mode: t.position.mode ?? rt.percent }), t.options && (this.options = zt({}, t.options))) } } !function (t) { t.screen = "screen", t.canvas = "canvas" }(Re || (Re = {})); class ii { constructor() { this.maxWidth = 1 / 0, this.options = {}, this.mode = Re.canvas } load(t) { t && (void 0 !== t.maxWidth && (this.maxWidth = t.maxWidth), void 0 !== t.mode && (t.mode === Re.screen ? this.mode = Re.screen : this.mode = Re.canvas), void 0 !== t.options && (this.options = zt({}, t.options))) } } !function (t) { t.any = "any", t.dark = "dark", t.light = "light" }(Ie || (Ie = {})); class si { constructor() { this.auto = !1, this.mode = Ie.any, this.value = !1 } load(t) { t && (void 0 !== t.auto && (this.auto = t.auto), void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.value && (this.value = t.value)) } } class oi { constructor() { this.name = "", this.default = new si } load(t) { t && (void 0 !== t.name && (this.name = t.name), this.default.load(t.default), void 0 !== t.options && (this.options = zt({}, t.options))) } } class ni { constructor() { this.count = 0, this.enable = !1, this.speed = 1, this.decay = 0, this.delay = 0, this.sync = !1 } load(t) { t && (void 0 !== t.count && (this.count = j(t.count)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed && (this.speed = j(t.speed)), void 0 !== t.decay && (this.decay = j(t.decay)), void 0 !== t.delay && (this.delay = j(t.delay)), void 0 !== t.sync && (this.sync = t.sync)) } } class ai extends ni { constructor() { super(), this.mode = st.auto, this.startValue = ct.random } load(t) { super.load(t), t && (void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.startValue && (this.startValue = t.startValue)) } } class ri extends ni { constructor() { super(), this.offset = 0, this.sync = !0 } load(t) { super.load(t), t && void 0 !== t.offset && (this.offset = j(t.offset)) } } class ci { constructor() { this.h = new ri, this.s = new ri, this.l = new ri } load(t) { t && (this.h.load(t.h), this.s.load(t.s), this.l.load(t.l)) } } class li extends Ve { constructor() { super(), this.animation = new ci } static create(t, e) { const i = new li; return i.load(t), void 0 !== e && (w(e) || P(e) ? i.load({ value: e }) : i.load(e)), i } load(t) { if (super.load(t), !t) return; const e = t.animation; void 0 !== e && (void 0 !== e.enable ? this.animation.h.load(e) : this.animation.load(t.animation)) } } !function (t) { t.absorb = "absorb", t.bounce = "bounce", t.destroy = "destroy" }(Ae || (Ae = {})); class hi { constructor() { this.speed = 2 } load(t) { t && void 0 !== t.speed && (this.speed = t.speed) } } class di { constructor() { this.enable = !0, this.retries = 0 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.retries && (this.retries = t.retries)) } } class ui { constructor() { this.value = 0 } load(t) { t && void 0 !== t.value && (this.value = j(t.value)) } } class pi extends ui { constructor() { super(), this.animation = new ni } load(t) { if (super.load(t), !t) return; const e = t.animation; void 0 !== e && this.animation.load(e) } } class fi extends pi { constructor() { super(), this.animation = new ai } load(t) { super.load(t) } } class mi extends ui { constructor() { super(), this.value = 1 } } class vi { constructor() { this.horizontal = new mi, this.vertical = new mi } load(t) { t && (this.horizontal.load(t.horizontal), this.vertical.load(t.vertical)) } } class yi { constructor() { this.absorb = new hi, this.bounce = new vi, this.enable = !1, this.maxSpeed = 50, this.mode = Ae.bounce, this.overlap = new di } load(t) { t && (this.absorb.load(t.absorb), this.bounce.load(t.bounce), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.maxSpeed && (this.maxSpeed = j(t.maxSpeed)), void 0 !== t.mode && (this.mode = t.mode), this.overlap.load(t.overlap)) } } class gi { constructor() { this.close = !0, this.fill = !0, this.options = {}, this.type = [] } load(t) { if (!t) return; const e = t.options; if (void 0 !== e) for (const t in e) { const i = e[t]; i && (this.options[t] = zt(this.options[t] ?? {}, i)) } void 0 !== t.close && (this.close = t.close), void 0 !== t.fill && (this.fill = t.fill), void 0 !== t.type && (this.type = t.type) } } class bi { constructor() { this.offset = 0, this.value = 90 } load(t) { t && (void 0 !== t.offset && (this.offset = j(t.offset)), void 0 !== t.value && (this.value = j(t.value))) } } class wi { constructor() { this.distance = 200, this.enable = !1, this.rotate = { x: 3e3, y: 3e3 } } load(t) { if (t && (void 0 !== t.distance && (this.distance = j(t.distance)), void 0 !== t.enable && (this.enable = t.enable), t.rotate)) { const e = t.rotate.x; void 0 !== e && (this.rotate.x = e); const i = t.rotate.y; void 0 !== i && (this.rotate.y = i) } } } class xi { constructor() { this.x = 50, this.y = 50, this.mode = rt.percent, this.radius = 0 } load(t) { t && (void 0 !== t.x && (this.x = t.x), void 0 !== t.y && (this.y = t.y), void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.radius && (this.radius = t.radius)) } } class _i { constructor() { this.acceleration = 9.81, this.enable = !1, this.inverse = !1, this.maxSpeed = 50 } load(t) { t && (void 0 !== t.acceleration && (this.acceleration = j(t.acceleration)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.inverse && (this.inverse = t.inverse), void 0 !== t.maxSpeed && (this.maxSpeed = j(t.maxSpeed))) } } class ki { constructor() { this.clamp = !0, this.delay = new ui, this.enable = !1, this.options = {} } load(t) { t && (void 0 !== t.clamp && (this.clamp = t.clamp), this.delay.load(t.delay), void 0 !== t.enable && (this.enable = t.enable), this.generator = t.generator, t.options && (this.options = zt(this.options, t.options))) } } class Pi { load(t) { t && (void 0 !== t.color && (this.color = Ve.create(this.color, t.color)), void 0 !== t.image && (this.image = t.image)) } } class zi { constructor() { this.enable = !1, this.length = 10, this.fill = new Pi } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.fill && this.fill.load(t.fill), void 0 !== t.length && (this.length = t.length)) } } !function (t) { t.bounce = "bounce", t.none = "none", t.out = "out", t.destroy = "destroy", t.split = "split" }(Fe || (Fe = {})); class Ci { constructor() { this.default = Fe.out } load(t) { t && (void 0 !== t.default && (this.default = t.default), this.bottom = t.bottom ?? t.default, this.left = t.left ?? t.default, this.right = t.right ?? t.default, this.top = t.top ?? t.default) } } class Mi { constructor() { this.acceleration = 0, this.enable = !1 } load(t) { t && (void 0 !== t.acceleration && (this.acceleration = j(t.acceleration)), void 0 !== t.enable && (this.enable = t.enable), t.position && (this.position = zt({}, t.position))) } } class Oi { constructor() { this.angle = new bi, this.attract = new wi, this.center = new xi, this.decay = 0, this.distance = {}, this.direction = g.none, this.drift = 0, this.enable = !1, this.gravity = new _i, this.path = new ki, this.outModes = new Ci, this.random = !1, this.size = !1, this.speed = 2, this.spin = new Mi, this.straight = !1, this.trail = new zi, this.vibrate = !1, this.warp = !1 } load(t) { if (!t) return; this.angle.load(x(t.angle) ? { value: t.angle } : t.angle), this.attract.load(t.attract), this.center.load(t.center), void 0 !== t.decay && (this.decay = j(t.decay)), void 0 !== t.direction && (this.direction = t.direction), void 0 !== t.distance && (this.distance = x(t.distance) ? { horizontal: t.distance, vertical: t.distance } : { ...t.distance }), void 0 !== t.drift && (this.drift = j(t.drift)), void 0 !== t.enable && (this.enable = t.enable), this.gravity.load(t.gravity); const e = t.outModes; void 0 !== e && (k(e) ? this.outModes.load(e) : this.outModes.load({ default: e })), this.path.load(t.path), void 0 !== t.random && (this.random = t.random), void 0 !== t.size && (this.size = t.size), void 0 !== t.speed && (this.speed = j(t.speed)), this.spin.load(t.spin), void 0 !== t.straight && (this.straight = t.straight), this.trail.load(t.trail), void 0 !== t.vibrate && (this.vibrate = t.vibrate), void 0 !== t.warp && (this.warp = t.warp) } } class Si extends ai { constructor() { super(), this.destroy = nt.none, this.speed = 2 } load(t) { super.load(t), t && void 0 !== t.destroy && (this.destroy = t.destroy) } } class Di extends fi { constructor() { super(), this.animation = new Si, this.value = 1 } load(t) { if (!t) return; super.load(t); const e = t.animation; void 0 !== e && this.animation.load(e) } } class Ti { constructor() { this.enable = !1, this.width = 1920, this.height = 1080 } load(t) { if (!t) return; void 0 !== t.enable && (this.enable = t.enable); const e = t.width; void 0 !== e && (this.width = e); const i = t.height; void 0 !== i && (this.height = i) } } !function (t) { t.delete = "delete", t.wait = "wait" }(Le || (Le = {})); class Ei { constructor() { this.mode = Le.delete, this.value = 0 } load(t) { t && (void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.value && (this.value = t.value)) } } class Ri { constructor() { this.density = new Ti, this.limit = new Ei, this.value = 0 } load(t) { t && (this.density.load(t.density), this.limit.load(t.limit), void 0 !== t.value && (this.value = t.value)) } } class Ii { constructor() { this.blur = 0, this.color = new Ve, this.enable = !1, this.offset = { x: 0, y: 0 }, this.color.value = "#000" } load(t) { t && (void 0 !== t.blur && (this.blur = t.blur), this.color = Ve.create(this.color, t.color), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.offset && (void 0 !== t.offset.x && (this.offset.x = t.offset.x), void 0 !== t.offset.y && (this.offset.y = t.offset.y))) } } class Ai { constructor() { this.close = !0, this.fill = !0, this.options = {}, this.type = "circle" } load(t) { if (!t) return; const e = t.options; if (void 0 !== e) for (const t in e) { const i = e[t]; i && (this.options[t] = zt(this.options[t] ?? {}, i)) } void 0 !== t.close && (this.close = t.close), void 0 !== t.fill && (this.fill = t.fill), void 0 !== t.type && (this.type = t.type) } } class Fi extends ai { constructor() { super(), this.destroy = nt.none, this.speed = 5 } load(t) { super.load(t), t && void 0 !== t.destroy && (this.destroy = t.destroy) } } class Li extends fi { constructor() { super(), this.animation = new Fi, this.value = 3 } load(t) { if (super.load(t), !t) return; const e = t.animation; void 0 !== e && this.animation.load(e) } } class Bi { constructor() { this.width = 0 } load(t) { t && (void 0 !== t.color && (this.color = li.create(this.color, t.color)), void 0 !== t.width && (this.width = j(t.width)), void 0 !== t.opacity && (this.opacity = j(t.opacity))) } } class qi extends ui { constructor() { super(), this.opacityRate = 1, this.sizeRate = 1, this.velocityRate = 1 } load(t) { super.load(t), t && (void 0 !== t.opacityRate && (this.opacityRate = t.opacityRate), void 0 !== t.sizeRate && (this.sizeRate = t.sizeRate), void 0 !== t.velocityRate && (this.velocityRate = t.velocityRate)) } } class Hi { constructor(t, e) { this._engine = t, this._container = e, this.bounce = new vi, this.collisions = new yi, this.color = new li, this.color.value = "#fff", this.effect = new gi, this.groups = {}, this.move = new Oi, this.number = new Ri, this.opacity = new Di, this.reduceDuplicates = !1, this.shadow = new Ii, this.shape = new Ai, this.size = new Li, this.stroke = new Bi, this.zIndex = new qi } load(t) { if (!t) return; if (void 0 !== t.groups) for (const e of Object.keys(t.groups)) { if (!Object.hasOwn(t.groups, e)) continue; const i = t.groups[e]; void 0 !== i && (this.groups[e] = zt(this.groups[e] ?? {}, i)) } void 0 !== t.reduceDuplicates && (this.reduceDuplicates = t.reduceDuplicates), this.bounce.load(t.bounce), this.color.load(li.create(this.color, t.color)), this.effect.load(t.effect), this.move.load(t.move), this.number.load(t.number), this.opacity.load(t.opacity), this.shape.load(t.shape), this.size.load(t.size), this.shadow.load(t.shadow), this.zIndex.load(t.zIndex), this.collisions.load(t.collisions), void 0 !== t.interactivity && (this.interactivity = zt({}, t.interactivity)); const e = t.stroke; if (e && (this.stroke = Rt(e, (t => { const e = new Bi; return e.load(t), e }))), this._container) { const e = this._engine.updaters.get(this._container); if (e) for (const i of e) i.loadOptions && i.loadOptions(this, t); const i = this._engine.interactors.get(this._container); if (i) for (const e of i) e.loadParticlesOptions && e.loadParticlesOptions(this, t) } } } function Ui(t, ...e) { for (const i of e) t.load(i) } function Vi(t, e, ...i) { const s = new Hi(t, e); return Ui(s, ...i), s } class Wi { constructor(t, e) { this._findDefaultTheme = t => this.themes.find((e => e.default.value && e.default.mode === t)) ?? this.themes.find((t => t.default.value && t.default.mode === Ie.any)), this._importPreset = t => { this.load(this._engine.getPreset(t)) }, this._engine = t, this._container = e, this.autoPlay = !0, this.background = new We, this.backgroundMask = new $e, this.clear = !0, this.defaultThemes = {}, this.delay = 0, this.fullScreen = new Ge, this.detectRetina = !0, this.duration = 0, this.fpsLimit = 120, this.interactivity = new ti(t, e), this.manualParticles = [], this.particles = Vi(this._engine, this._container), this.pauseOnBlur = !0, this.pauseOnOutsideViewport = !0, this.responsive = [], this.smooth = !1, this.style = {}, this.themes = [], this.zLayers = 100 } load(t) { if (!t) return; void 0 !== t.preset && Rt(t.preset, (t => this._importPreset(t))), void 0 !== t.autoPlay && (this.autoPlay = t.autoPlay), void 0 !== t.clear && (this.clear = t.clear), void 0 !== t.key && (this.key = t.key), void 0 !== t.name && (this.name = t.name), void 0 !== t.delay && (this.delay = j(t.delay)); const e = t.detectRetina; void 0 !== e && (this.detectRetina = e), void 0 !== t.duration && (this.duration = j(t.duration)); const i = t.fpsLimit; void 0 !== i && (this.fpsLimit = i), void 0 !== t.pauseOnBlur && (this.pauseOnBlur = t.pauseOnBlur), void 0 !== t.pauseOnOutsideViewport && (this.pauseOnOutsideViewport = t.pauseOnOutsideViewport), void 0 !== t.zLayers && (this.zLayers = t.zLayers), this.background.load(t.background); const s = t.fullScreen; b(s) ? this.fullScreen.enable = s : this.fullScreen.load(s), this.backgroundMask.load(t.backgroundMask), this.interactivity.load(t.interactivity), t.manualParticles && (this.manualParticles = t.manualParticles.map((t => { const e = new ei; return e.load(t), e }))), this.particles.load(t.particles), this.style = zt(this.style, t.style), this._engine.loadOptions(this, t), void 0 !== t.smooth && (this.smooth = t.smooth); const o = this._engine.interactors.get(this._container); if (o) for (const e of o) e.loadOptions && e.loadOptions(this, t); if (void 0 !== t.responsive) for (const e of t.responsive) { const t = new ii; t.load(e), this.responsive.push(t) } if (this.responsive.sort(((t, e) => t.maxWidth - e.maxWidth)), void 0 !== t.themes) for (const e of t.themes) { const t = this.themes.find((t => t.name === e.name)); if (t) t.load(e); else { const t = new oi; t.load(e), this.themes.push(t) } } this.defaultThemes.dark = this._findDefaultTheme(Ie.dark)?.name, this.defaultThemes.light = this._findDefaultTheme(Ie.light)?.name } setResponsive(t, e, i) { this.load(i); const s = this.responsive.find((i => i.mode === Re.screen && screen ? i.maxWidth > screen.availWidth : i.maxWidth * e > t)); return this.load(s?.options), s?.maxWidth } setTheme(t) { if (t) { const e = this.themes.find((e => e.name === t)); e && this.load(e.options) } else { const t = mt("(prefers-color-scheme: dark)"), e = t?.matches, i = this._findDefaultTheme(e ? Ie.dark : Ie.light); i && this.load(i.options) } } } !function (t) { t.external = "external", t.particles = "particles" }(Be || (Be = {})); class ji { constructor(t, e) { this.container = e, this._engine = t, this._interactors = [], this._externalInteractors = [], this._particleInteractors = [] } externalInteract(t) { for (const e of this._externalInteractors) e.isEnabled() && e.interact(t) } handleClickMode(t) { for (const e of this._externalInteractors) e.handleClickMode?.(t) } async init() { this._interactors = await this._engine.getInteractors(this.container, !0), this._externalInteractors = [], this._particleInteractors = []; for (const t of this._interactors) { switch (t.type) { case Be.external: this._externalInteractors.push(t); break; case Be.particles: this._particleInteractors.push(t) }t.init() } } particlesInteract(t, e) { for (const i of this._externalInteractors) i.clear(t, e); for (const i of this._particleInteractors) i.isEnabled(t) && i.interact(t, e) } reset(t) { for (const e of this._externalInteractors) e.isEnabled() && e.reset(t); for (const e of this._particleInteractors) e.isEnabled(t) && e.reset(t) } } !function (t) { t.normal = "normal", t.inside = "inside", t.outside = "outside" }(qe || (qe = {})); const $i = .5, Gi = "random"; function Ni(t) { if (!gt(t.outMode, t.checkModes)) return; const e = 2 * t.radius; t.coord > t.maxCoord - e ? t.setCb(-t.radius) : t.coord < e && t.setCb(t.radius) } class Qi { constructor(t, e) { this.container = e, this._calcPosition = (t, e, i, s = 0) => { for (const [, s] of t.plugins) { const t = void 0 !== s.particlePosition ? s.particlePosition(e, this) : void 0; if (t) return z.create(t.x, t.y, i) } const o = tt({ size: t.canvas.size, position: e }), n = z.create(o.x, o.y, i), a = this.getRadius(), r = this.options.move.outModes, c = e => { Ni({ outMode: e, checkModes: [Fe.bounce], coord: n.x, maxCoord: t.canvas.size.width, setCb: t => n.x += t, radius: a }) }, l = e => { Ni({ outMode: e, checkModes: [Fe.bounce], coord: n.y, maxCoord: t.canvas.size.height, setCb: t => n.y += t, radius: a }) }; if (c(r.left ?? r.default), c(r.right ?? r.default), l(r.top ?? r.default), l(r.bottom ?? r.default), this._checkOverlap(n, s)) { const e = 1; return this._calcPosition(t, void 0, i, s + e) } return n }, this._calculateVelocity = () => { const t = Z(this.direction).copy(), e = this.options.move; if (e.direction === g.inside || e.direction === g.outside) return t; const i = N(U(e.angle.value)), s = N(U(e.angle.offset)), o = { left: s - i * $i, right: s + i * $i }; return e.straight || (t.angle += H(j(o.left, o.right))), e.random && "number" == typeof e.speed && (t.length *= I()), t }, this._checkOverlap = (t, e = 0) => { const i = this.options.collisions, s = this.getRadius(); if (!i.enable) return !1; const o = i.overlap; if (o.enable) return !1; const n = o.retries; if (n >= 0 && e > n) throw new Error(`${f} particle is overlapping and can't be placed`); return !!this.container.particles.find((e => G(t, e.position) < s + e.getRadius())) }, this._getRollColor = t => { if (!t || !this.roll || !this.backColor && !this.roll.alter) return t; const e = this.roll.horizontal && this.roll.vertical ? 2 : 1, i = this.roll.horizontal ? Math.PI * $i : 0; return Math.floor(((this.roll.angle ?? 0) + i) / (Math.PI / e)) % 2 ? this.backColor ? this.backColor : this.roll.alter ? Ce(t, this.roll.alter.type, this.roll.alter.value) : t : t }, this._initPosition = t => { const e = this.container, i = U(this.options.zIndex.value); this.position = this._calcPosition(e, t, B(i, 0, e.zLayers)), this.initialPosition = this.position.copy(); const s = e.canvas.size; switch (this.moveCenter = { ...Bt(this.options.move.center, s), radius: this.options.move.center.radius ?? 0, mode: this.options.move.center.mode ?? rt.percent }, this.direction = Q(this.options.move.direction, this.position, this.moveCenter), this.options.move.direction) { case g.inside: this.outType = qe.inside; break; case g.outside: this.outType = qe.outside }this.offset = C.origin }, this._engine = t } destroy(t) { if (this.unbreakable || this.destroyed) return; this.destroyed = !0, this.bubble.inRange = !1, this.slow.inRange = !1; const e = this.container, i = this.pathGenerator, s = e.shapeDrawers.get(this.shape); s?.particleDestroy?.(this); for (const [, i] of e.plugins) i.particleDestroyed?.(this, t); for (const i of e.particles.updaters) i.particleDestroyed?.(this, t); i?.reset(this), this._engine.dispatchEvent(Te.particleDestroyed, { container: this.container, data: { particle: this } }) } draw(t) { const e = this.container, i = e.canvas; for (const [, s] of e.plugins) i.drawParticlePlugin(s, this, t); i.drawParticle(this, t) } getFillColor() { return this._getRollColor(this.bubble.color ?? le(this.color)) } getMass() { return this.getRadius() ** 2 * Math.PI * $i } getPosition() { return { x: this.position.x + this.offset.x, y: this.position.y + this.offset.y, z: this.position.z } } getRadius() { return this.bubble.radius ?? this.size.value } getStrokeColor() { return this._getRollColor(this.bubble.color ?? le(this.strokeColor)) } init(t, e, i, s) { const o = this.container, n = this._engine; this.id = t, this.group = s, this.effectClose = !0, this.effectFill = !0, this.shapeClose = !0, this.shapeFill = !0, this.pathRotation = !1, this.lastPathTime = 0, this.destroyed = !1, this.unbreakable = !1, this.isRotating = !1, this.rotation = 0, this.misplaced = !1, this.retina = { maxDistance: {} }, this.outType = qe.normal, this.ignoresResizeRatio = !0; const a = o.retina.pixelRatio, r = o.actualOptions, c = Vi(this._engine, o, r.particles), { reduceDuplicates: l } = c, h = c.effect.type, d = c.shape.type; this.effect = It(h, this.id, l), this.shape = It(d, this.id, l); const u = c.effect, p = c.shape; if (i) { if (i.effect?.type) { const t = It(i.effect.type, this.id, l); t && (this.effect = t, u.load(i.effect)) } if (i.shape?.type) { const t = It(i.shape.type, this.id, l); t && (this.shape = t, p.load(i.shape)) } } if (this.effect === Gi) { const t = [...this.container.effectDrawers.keys()]; this.effect = t[Math.floor(Math.random() * t.length)] } if (this.shape === Gi) { const t = [...this.container.shapeDrawers.keys()]; this.shape = t[Math.floor(Math.random() * t.length)] } this.effectData = function (t, e, i, s) { const o = e.options[t]; if (o) return zt({ close: e.close, fill: e.fill }, It(o, i, s)) }(this.effect, u, this.id, l), this.shapeData = function (t, e, i, s) { const o = e.options[t]; if (o) return zt({ close: e.close, fill: e.fill }, It(o, i, s)) }(this.shape, p, this.id, l), c.load(i); const f = this.effectData; f && c.load(f.particles); const m = this.shapeData; m && c.load(m.particles); const v = new ti(n, o); v.load(o.actualOptions.interactivity), v.load(c.interactivity), this.interactivity = v, this.effectFill = f?.fill ?? c.effect.fill, this.effectClose = f?.close ?? c.effect.close, this.shapeFill = m?.fill ?? c.shape.fill, this.shapeClose = m?.close ?? c.shape.close, this.options = c; const g = this.options.move.path; this.pathDelay = U(g.delay.value) * y, g.generator && (this.pathGenerator = this._engine.getPathGenerator(g.generator), this.pathGenerator && o.addPath(g.generator, this.pathGenerator) && this.pathGenerator.init(o)), o.retina.initParticle(this), this.size = Ft(this.options.size, a), this.bubble = { inRange: !1 }, this.slow = { inRange: !1, factor: 1 }, this._initPosition(e), this.initialVelocity = this._calculateVelocity(), this.velocity = this.initialVelocity.copy(), this.moveDecay = 1 - U(this.options.move.decay); const b = o.particles; b.setLastZIndex(this.position.z), this.zIndexFactor = this.position.z / o.zLayers, this.sides = 24; let w = o.effectDrawers.get(this.effect); w || (w = this._engine.getEffectDrawer(this.effect), w && o.effectDrawers.set(this.effect, w)), w?.loadEffect && w.loadEffect(this); let x = o.shapeDrawers.get(this.shape); x || (x = this._engine.getShapeDrawer(this.shape), x && o.shapeDrawers.set(this.shape, x)), x?.loadShape && x.loadShape(this); const _ = x?.getSidesCount; _ && (this.sides = _(this)), this.spawning = !1, this.shadowColor = Qt(this.options.shadow.color); for (const t of b.updaters) t.init(this); for (const t of b.movers) t.init?.(this); w?.particleInit?.(o, this), x?.particleInit?.(o, this); for (const [, t] of o.plugins) t.particleCreated?.(this) } isInsideCanvas() { const t = this.getRadius(), e = this.container.canvas.size, i = this.position; return i.x >= -t && i.y >= -t && i.y <= e.height + t && i.x <= e.width + t } isVisible() { return !this.destroyed && !this.spawning && this.isInsideCanvas() } reset() { for (const t of this.container.particles.updaters) t.reset?.(this) } } class Zi { constructor(t, e) { this.position = t, this.particle = e } } var Xi; !function (t) { t.circle = "circle", t.rectangle = "rectangle" }(Xi || (Xi = {})); class Yi { constructor(t, e, i) { this.position = { x: t, y: e }, this.type = i } } class Ji extends Yi { constructor(t, e, i) { super(t, e, Xi.circle), this.radius = i } contains(t) { return G(t, this.position) <= this.radius } intersects(t) { const e = this.position, i = t.position, s = Math.abs(i.x - e.x), o = Math.abs(i.y - e.y), n = this.radius; if (t instanceof Ji || t.type === Xi.circle) return n + t.radius > Math.sqrt(s ** 2 + o ** 2); if (t instanceof Ki || t.type === Xi.rectangle) { const e = t, { width: i, height: a } = e.size; return Math.pow(s - i, 2) + Math.pow(o - a, 2) <= n ** 2 || s <= n + i && o <= n + a || s <= i || o <= a } return !1 } } class Ki extends Yi { constructor(t, e, i, s) { super(t, e, Xi.rectangle), this.size = { height: s, width: i } } contains(t) { const e = this.size.width, i = this.size.height, s = this.position; return t.x >= s.x && t.x <= s.x + e && t.y >= s.y && t.y <= s.y + i } intersects(t) { if (t instanceof Ji) return t.intersects(this); const e = this.size.width, i = this.size.height, s = this.position, o = t.position, n = t instanceof Ki ? t.size : { width: 0, height: 0 }, a = n.width, r = n.height; return o.x < s.x + e && o.x + a > s.x && o.y < s.y + i && o.y + r > s.y } } const ts = .5; class es { constructor(t, e) { this.rectangle = t, this.capacity = e, this._subdivide = () => { const { x: t, y: e } = this.rectangle.position, { width: i, height: s } = this.rectangle.size, { capacity: o } = this; for (let n = 0; n < 4; n++) { const a = n % 2; this._subs.push(new es(new Ki(t + i * ts * a, e + s * ts * (Math.round(n * ts) - a), i * ts, s * ts), o)) } this._divided = !0 }, this._points = [], this._divided = !1, this._subs = [] } insert(t) { return !!this.rectangle.contains(t.position) && (this._points.length < this.capacity ? (this._points.push(t), !0) : (this._divided || this._subdivide(), this._subs.some((e => e.insert(t))))) } query(t, e) { const i = []; if (!t.intersects(this.rectangle)) return []; for (const s of this._points) !t.contains(s.position) && G(t.position, s.position) > s.particle.getRadius() && (!e || e(s.particle)) || i.push(s.particle); if (this._divided) for (const s of this._subs) i.push(...s.query(t, e)); return i } queryCircle(t, e, i) { return this.query(new Ji(t.x, t.y, e), i) } queryRectangle(t, e, i) { return this.query(new Ki(t.x, t.y, e.width, e.height), i) } } const is = t => { const { height: e, width: i } = t; return new Ki(-.25 * i, -.25 * e, 1.5 * i, 1.5 * e) }; class ss { constructor(t, e) { this._addToPool = (...t) => { this._pool.push(...t) }, this._applyDensity = (t, e, i) => { const s = t.number; if (!t.number.density?.enable) return void (void 0 === i ? this._limit = s.limit.value : s.limit && this._groupLimits.set(i, s.limit.value)); const o = this._initDensityFactor(s.density), n = s.value, a = s.limit.value > 0 ? s.limit.value : n, r = Math.min(n, a) * o + e, c = Math.min(this.count, this.filter((t => t.group === i)).length); void 0 === i ? this._limit = s.limit.value * o : this._groupLimits.set(i, s.limit.value * o), c < r ? this.push(Math.abs(r - c), void 0, t, i) : c > r && this.removeQuantity(c - r, i) }, this._initDensityFactor = t => { const e = this._container; if (!e.canvas.element || !t.enable) return 1; const i = e.canvas.element, s = e.retina.pixelRatio; return i.width * i.height / (t.height * t.width * s ** 2) }, this._pushParticle = (t, e, i, s) => { try { let o = this._pool.pop(); o || (o = new Qi(this._engine, this._container)), o.init(this._nextId, t, e, i); let n = !0; if (s && (n = s(o)), !n) return; return this._array.push(o), this._zArray.push(o), this._nextId++, this._engine.dispatchEvent(Te.particleAdded, { container: this._container, data: { particle: o } }), o } catch (t) { dt().warning(`${f} adding particle: ${t}`) } }, this._removeParticle = (t, e, i) => { const s = this._array[t]; if (!s || s.group !== e) return !1; const o = this._zArray.indexOf(s); return this._array.splice(t, 1), this._zArray.splice(o, 1), s.destroy(i), this._engine.dispatchEvent(Te.particleRemoved, { container: this._container, data: { particle: s } }), this._addToPool(s), !0 }, this._engine = t, this._container = e, this._nextId = 0, this._array = [], this._zArray = [], this._pool = [], this._limit = 0, this._groupLimits = new Map, this._needsSort = !1, this._lastZIndex = 0, this._interactionManager = new ji(t, e), this._pluginsInitialized = !1; const i = e.canvas.size; this.quadTree = new es(is(i), 4), this.movers = [], this.updaters = [] } get count() { return this._array.length } addManualParticles() { const t = this._container; t.actualOptions.manualParticles.forEach((e => this.addParticle(e.position ? Bt(e.position, t.canvas.size) : void 0, e.options))) } addParticle(t, e, i, s) { const o = this._container.actualOptions.particles.number.limit.mode, n = void 0 === i ? this._limit : this._groupLimits.get(i) ?? this._limit, a = this.count; if (n > 0) switch (o) { case Le.delete: { const t = a + 1 - n; t > 0 && this.removeQuantity(t); break } case Le.wait: if (a >= n) return }return this._pushParticle(t, e, i, s) } clear() { this._array = [], this._zArray = [], this._pluginsInitialized = !1 } destroy() { this._array = [], this._zArray = [], this.movers = [], this.updaters = [] } draw(t) { const e = this._container, i = e.canvas; i.clear(), this.update(t); for (const [, s] of e.plugins) i.drawPlugin(s, t); for (const e of this._zArray) e.draw(t) } filter(t) { return this._array.filter(t) } find(t) { return this._array.find(t) } get(t) { return this._array[t] } handleClickMode(t) { this._interactionManager.handleClickMode(t) } async init() { const t = this._container, e = t.actualOptions; this._lastZIndex = 0, this._needsSort = !1, await this.initPlugins(); let i = !1; for (const [, e] of t.plugins) if (i = e.particlesInitialization?.() ?? i, i) break; if (this.addManualParticles(), !i) { const t = e.particles, i = t.groups; for (const e in i) { const s = i[e]; for (let i = this.count, o = 0; o < s.number?.value && i < t.number.value; i++, o++)this.addParticle(void 0, s, e) } for (let e = this.count; e < t.number.value; e++)this.addParticle() } } async initPlugins() { if (this._pluginsInitialized) return; const t = this._container; this.movers = await this._engine.getMovers(t, !0), this.updaters = await this._engine.getUpdaters(t, !0), await this._interactionManager.init(); for (const [, e] of t.pathGenerators) e.init(t) } push(t, e, i, s) { for (let o = 0; o < t; o++)this.addParticle(e?.position, i, s) } async redraw() { this.clear(), await this.init(), this.draw({ value: 0, factor: 0 }) } remove(t, e, i) { this.removeAt(this._array.indexOf(t), void 0, e, i) } removeAt(t, e = 1, i, s) { if (t < 0 || t > this.count) return; let o = 0; for (let n = t; o < e && n < this.count; n++)this._removeParticle(n--, i, s) && o++ } removeQuantity(t, e) { this.removeAt(0, t, e) } setDensity() { const t = this._container.actualOptions, e = t.particles.groups; for (const t in e) this._applyDensity(e[t], 0, t); this._applyDensity(t.particles, t.manualParticles.length) } setLastZIndex(t) { this._lastZIndex = t, this._needsSort = this._needsSort || this._lastZIndex < t } setResizeFactor(t) { this._resizeFactor = t } update(t) { const e = this._container, i = new Set; this.quadTree = new es(is(e.canvas.size), 4); for (const [, t] of e.pathGenerators) t.update(); for (const [, i] of e.plugins) i.update?.(t); const s = this._resizeFactor; for (const e of this._array) { s && !e.ignoresResizeRatio && (e.position.x *= s.width, e.position.y *= s.height, e.initialPosition.x *= s.width, e.initialPosition.y *= s.height), e.ignoresResizeRatio = !1, this._interactionManager.reset(e); for (const [, i] of this._container.plugins) { if (e.destroyed) break; i.particleUpdate?.(e, t) } for (const i of this.movers) i.isEnabled(e) && i.move(e, t); e.destroyed ? i.add(e) : this.quadTree.insert(new Zi(e.getPosition(), e)) } if (i.size) { const t = t => !i.has(t); this._array = this.filter(t), this._zArray = this._zArray.filter(t); for (const t of i) this._engine.dispatchEvent(Te.particleRemoved, { container: this._container, data: { particle: t } }); this._addToPool(...i) } this._interactionManager.externalInteract(t); for (const e of this._array) { for (const i of this.updaters) i.update(e, t); e.destroyed || e.spawning || this._interactionManager.particlesInteract(e, t) } if (delete this._resizeFactor, this._needsSort) { const t = this._zArray; t.sort(((t, e) => e.position.z - t.position.z || t.id - e.id)); const e = 1; this._lastZIndex = t[t.length - e].position.z, this._needsSort = !1 } } } class os { constructor(t) { this.container = t, this.pixelRatio = 1, this.reduceFactor = 1 } init() { const t = this.container, e = t.actualOptions; this.pixelRatio = !e.detectRetina || pt() ? 1 : window.devicePixelRatio, this.reduceFactor = 1; const i = this.pixelRatio, s = t.canvas; if (s.element) { const t = s.element; s.size.width = t.offsetWidth * i, s.size.height = t.offsetHeight * i } const o = e.particles, n = o.move; this.maxSpeed = U(n.gravity.maxSpeed) * i, this.sizeAnimationSpeed = U(o.size.animation.speed) * i } initParticle(t) { const e = t.options, i = this.pixelRatio, s = e.move, o = s.distance, n = t.retina; n.moveDrift = U(s.drift) * i, n.moveSpeed = U(s.speed) * i, n.sizeAnimationSpeed = U(e.size.animation.speed) * i; const a = n.maxDistance; a.horizontal = void 0 !== o.horizontal ? o.horizontal * i : void 0, a.vertical = void 0 !== o.vertical ? o.vertical * i : void 0, n.maxSpeed = U(s.gravity.maxSpeed) * i } } function ns(t) { return t && !t.destroyed } function as(t, e, ...i) { const s = new Wi(t, e); return Ui(s, ...i), s } class rs { constructor(t, e, i) { this._intersectionManager = t => { if (ns(this) && this.actualOptions.pauseOnOutsideViewport) for (const e of t) e.target === this.interactivity.element && (e.isIntersecting ? this.play() : this.pause()) }, this._nextFrame = t => { try { if (!this._smooth && void 0 !== this._lastFrameTime && t < this._lastFrameTime + y / this.fpsLimit) return void this.draw(!1); this._lastFrameTime ??= t; const e = function (t, e = 60, i = !1) { return { value: t, factor: i ? 60 / e : 60 * t / y } }(t - this._lastFrameTime, this.fpsLimit, this._smooth); if (this.addLifeTime(e.value), this._lastFrameTime = t, e.value > y) return void this.draw(!1); if (this.particles.draw(e), !this.alive()) return void this.destroy(); this.animationStatus && this.draw(!1) } catch (t) { dt().error(`${f} in animation loop`, t) } }, this._engine = t, this.id = Symbol(e), this.fpsLimit = 120, this._smooth = !1, this._delay = 0, this._duration = 0, this._lifeTime = 0, this._firstStart = !0, this.started = !1, this.destroyed = !1, this._paused = !0, this._lastFrameTime = 0, this.zLayers = 100, this.pageHidden = !1, this._clickHandlers = new Map, this._sourceOptions = i, this._initialSourceOptions = i, this.retina = new os(this), this.canvas = new Se(this), this.particles = new ss(this._engine, this), this.pathGenerators = new Map, this.interactivity = { mouse: { clicking: !1, inside: !1 } }, this.plugins = new Map, this.effectDrawers = new Map, this.shapeDrawers = new Map, this._options = as(this._engine, this), this.actualOptions = as(this._engine, this), this._eventListeners = new Ue(this), this._intersectionObserver = vt((t => this._intersectionManager(t))), this._engine.dispatchEvent(Te.containerBuilt, { container: this }) } get animationStatus() { return !this._paused && !this.pageHidden && ns(this) } get options() { return this._options } get sourceOptions() { return this._sourceOptions } addClickHandler(t) { if (!ns(this)) return; const e = this.interactivity.element; if (!e) return; const i = (e, i, s) => { if (!ns(this)) return; const o = this.retina.pixelRatio, n = { x: i.x * o, y: i.y * o }, a = this.particles.quadTree.queryCircle(n, s * o); t(e, a) }; let s = !1, o = !1; this._clickHandlers.set("click", (t => { if (!ns(this)) return; const e = t, s = { x: e.offsetX || e.clientX, y: e.offsetY || e.clientY }; i(t, s, 1) })), this._clickHandlers.set("touchstart", (() => { ns(this) && (s = !0, o = !1) })), this._clickHandlers.set("touchmove", (() => { ns(this) && (o = !0) })), this._clickHandlers.set("touchend", (t => { if (ns(this)) { if (s && !o) { const e = t, s = 1; let o = e.touches[e.touches.length - s]; if (!o && (o = e.changedTouches[e.changedTouches.length - s], !o)) return; const n = this.canvas.element, a = n ? n.getBoundingClientRect() : void 0, r = 0, c = { x: o.clientX - (a ? a.left : r), y: o.clientY - (a ? a.top : r) }; i(t, c, Math.max(o.radiusX, o.radiusY)) } s = !1, o = !1 } })), this._clickHandlers.set("touchcancel", (() => { ns(this) && (s = !1, o = !1) })); for (const [t, i] of this._clickHandlers) e.addEventListener(t, i) } addLifeTime(t) { this._lifeTime += t } addPath(t, e, i = !1) { return !(!ns(this) || !i && this.pathGenerators.has(t) || (this.pathGenerators.set(t, e), 0)) } alive() { return !this._duration || this._lifeTime <= this._duration } clearClickHandlers() { if (ns(this)) { for (const [t, e] of this._clickHandlers) this.interactivity.element?.removeEventListener(t, e); this._clickHandlers.clear() } } destroy(t = !0) { if (ns(this)) { this.stop(), this.clearClickHandlers(), this.particles.destroy(), this.canvas.destroy(); for (const [, t] of this.effectDrawers) t.destroy?.(this); for (const [, t] of this.shapeDrawers) t.destroy?.(this); for (const t of this.effectDrawers.keys()) this.effectDrawers.delete(t); for (const t of this.shapeDrawers.keys()) this.shapeDrawers.delete(t); if (this._engine.clearPlugins(this), this.destroyed = !0, t) { const t = this._engine.items, e = t.findIndex((t => t === this)); if (e >= 0) { const i = 1; t.splice(e, i) } } this._engine.dispatchEvent(Te.containerDestroyed, { container: this }) } } draw(t) { if (!ns(this)) return; let e = t; const i = t => { e && (this._lastFrameTime = void 0, e = !1), this._nextFrame(t) }; this._drawAnimationFrame = F((t => i(t))) } async export(t, e = {}) { for (const [, i] of this.plugins) { if (!i.export) continue; const s = await i.export(t, e); if (s.supported) return s.blob } dt().error(`${f} - Export plugin with type ${t} not found`) } handleClickMode(t) { if (ns(this)) { this.particles.handleClickMode(t); for (const [, e] of this.plugins) e.handleClickMode?.(t) } } async init() { if (!ns(this)) return; const t = this._engine.getSupportedEffects(); for (const e of t) { const t = this._engine.getEffectDrawer(e); t && this.effectDrawers.set(e, t) } const e = this._engine.getSupportedShapes(); for (const t of e) { const e = this._engine.getShapeDrawer(t); e && this.shapeDrawers.set(t, e) } await this.particles.initPlugins(), this._options = as(this._engine, this, this._initialSourceOptions, this.sourceOptions), this.actualOptions = as(this._engine, this, this._options); const i = await this._engine.getAvailablePlugins(this); for (const [t, e] of i) this.plugins.set(t, e); this.retina.init(), await this.canvas.init(), this.updateActualOptions(), this.canvas.initBackground(), this.canvas.resize(); const { zLayers: s, duration: o, delay: n, fpsLimit: a, smooth: r } = this.actualOptions; this.zLayers = s, this._duration = U(o) * y, this._delay = U(n) * y, this._lifeTime = 0, this.fpsLimit = a > 0 ? a : 120, this._smooth = r; for (const [, t] of this.effectDrawers) await (t.init?.(this)); for (const [, t] of this.shapeDrawers) await (t.init?.(this)); for (const [, t] of this.plugins) await (t.init?.()); this._engine.dispatchEvent(Te.containerInit, { container: this }), await this.particles.init(), this.particles.setDensity(); for (const [, t] of this.plugins) t.particlesSetup?.(); this._engine.dispatchEvent(Te.particlesSetup, { container: this }) } async loadTheme(t) { ns(this) && (this._currentTheme = t, await this.refresh()) } pause() { if (ns(this) && (void 0 !== this._drawAnimationFrame && (L(this._drawAnimationFrame), delete this._drawAnimationFrame), !this._paused)) { for (const [, t] of this.plugins) t.pause?.(); this.pageHidden || (this._paused = !0), this._engine.dispatchEvent(Te.containerPaused, { container: this }) } } play(t) { if (!ns(this)) return; const e = this._paused || t; if (!this._firstStart || this.actualOptions.autoPlay) { if (this._paused && (this._paused = !1), e) for (const [, t] of this.plugins) t.play && t.play(); this._engine.dispatchEvent(Te.containerPlay, { container: this }), this.draw(e ?? !1) } else this._firstStart = !1 } async refresh() { if (ns(this)) return this.stop(), this.start() } async reset(t) { if (ns(this)) return this._initialSourceOptions = t, this._sourceOptions = t, this._options = as(this._engine, this, this._initialSourceOptions, this.sourceOptions), this.actualOptions = as(this._engine, this, this._options), this.refresh() } async start() { ns(this) && !this.started && (await this.init(), this.started = !0, await new Promise((t => { const e = async () => { this._eventListeners.addListeners(), this.interactivity.element instanceof HTMLElement && this._intersectionObserver && this._intersectionObserver.observe(this.interactivity.element); for (const [, t] of this.plugins) await (t.start?.()); this._engine.dispatchEvent(Te.containerStarted, { container: this }), this.play(), t() }; this._delayTimeout = setTimeout((() => { e() }), this._delay) }))) } stop() { if (ns(this) && this.started) { this._delayTimeout && (clearTimeout(this._delayTimeout), delete this._delayTimeout), this._firstStart = !0, this.started = !1, this._eventListeners.removeListeners(), this.pause(), this.particles.clear(), this.canvas.stop(), this.interactivity.element instanceof HTMLElement && this._intersectionObserver && this._intersectionObserver.unobserve(this.interactivity.element); for (const [, t] of this.plugins) t.stop?.(); for (const t of this.plugins.keys()) this.plugins.delete(t); this._sourceOptions = this._options, this._engine.dispatchEvent(Te.containerStopped, { container: this }) } } updateActualOptions() { this.actualOptions.responsive = []; const t = this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, this._options); return this.actualOptions.setTheme(this._currentTheme), this._responsiveMaxWidth !== t && (this._responsiveMaxWidth = t, !0) } } class cs { constructor() { this._listeners = new Map } addEventListener(t, e) { this.removeEventListener(t, e); let i = this._listeners.get(t); i || (i = [], this._listeners.set(t, i)), i.push(e) } dispatchEvent(t, e) { const i = this._listeners.get(t); i?.forEach((t => t(e))) } hasEventListener(t) { return !!this._listeners.get(t) } removeAllEventListeners(t) { t ? this._listeners.delete(t) : this._listeners = new Map } removeEventListener(t, e) { const i = this._listeners.get(t); if (!i) return; const s = i.length, o = i.indexOf(e); o < 0 || (1 === s ? this._listeners.delete(t) : i.splice(o, 1)) } } async function ls(t, e, i, s = !1) { let o = e.get(t); return o && !s || (o = await Promise.all([...i.values()].map((e => e(t)))), e.set(t, o)), o } const hs = "true", ds = "false", us = "canvas"; class ps { constructor() { this._configs = new Map, this._domArray = [], this._eventDispatcher = new cs, this._initialized = !1, this.plugins = [], this._initializers = { interactors: new Map, movers: new Map, updaters: new Map }, this.interactors = new Map, this.movers = new Map, this.updaters = new Map, this.presets = new Map, this.effectDrawers = new Map, this.shapeDrawers = new Map, this.pathGenerators = new Map } get configs() { const t = {}; for (const [e, i] of this._configs) t[e] = i; return t } get items() { return this._domArray } get version() { return "3.5.0" } addConfig(t) { const e = t.key ?? t.name ?? "default"; this._configs.set(e, t), this._eventDispatcher.dispatchEvent(Te.configAdded, { data: { name: e, config: t } }) } async addEffect(t, e, i = !0) { Rt(t, (t => { this.getEffectDrawer(t) || this.effectDrawers.set(t, e) })), await this.refresh(i) } addEventListener(t, e) { this._eventDispatcher.addEventListener(t, e) } async addInteractor(t, e, i = !0) { this._initializers.interactors.set(t, e), await this.refresh(i) } async addMover(t, e, i = !0) { this._initializers.movers.set(t, e), await this.refresh(i) } async addParticleUpdater(t, e, i = !0) { this._initializers.updaters.set(t, e), await this.refresh(i) } async addPathGenerator(t, e, i = !0) { this.getPathGenerator(t) || this.pathGenerators.set(t, e), await this.refresh(i) } async addPlugin(t, e = !0) { this.getPlugin(t.id) || this.plugins.push(t), await this.refresh(e) } async addPreset(t, e, i = !1, s = !0) { !i && this.getPreset(t) || this.presets.set(t, e), await this.refresh(s) } async addShape(t, e = !0) { for (const e of t.validTypes) this.getShapeDrawer(e) || this.shapeDrawers.set(e, t); await this.refresh(e) } clearPlugins(t) { this.updaters.delete(t), this.movers.delete(t), this.interactors.delete(t) } dispatchEvent(t, e) { this._eventDispatcher.dispatchEvent(t, e) } dom() { return this.items } domItem(t) { return this.item(t) } async getAvailablePlugins(t) { const e = new Map; for (const i of this.plugins) i.needsPlugin(t.actualOptions) && e.set(i.id, await i.getPlugin(t)); return e } getEffectDrawer(t) { return this.effectDrawers.get(t) } async getInteractors(t, e = !1) { return ls(t, this.interactors, this._initializers.interactors, e) } async getMovers(t, e = !1) { return ls(t, this.movers, this._initializers.movers, e) } getPathGenerator(t) { return this.pathGenerators.get(t) } getPlugin(t) { return this.plugins.find((e => e.id === t)) } getPreset(t) { return this.presets.get(t) } getShapeDrawer(t) { return this.shapeDrawers.get(t) } getSupportedEffects() { return this.effectDrawers.keys() } getSupportedShapes() { return this.shapeDrawers.keys() } async getUpdaters(t, e = !1) { return ls(t, this.updaters, this._initializers.updaters, e) } init() { this._initialized || (this._initialized = !0) } item(t) { const { items: e } = this, i = e[t]; if (i && !i.destroyed) return i; { const i = 1; e.splice(t, i) } } async load(t) { const e = t.id ?? t.element?.id ?? `tsparticles${Math.floor(1e4 * I())}`, { index: s, url: o } = t, n = o ? await async function (t) { const e = It(t.url, t.index); if (!e) return t.fallback; const i = await fetch(e); return i.ok ? await i.json() : (dt().error(`${f} ${i.status} while retrieving config file`), t.fallback) }({ fallback: t.options, url: o, index: s }) : t.options, a = It(n, s), { items: r } = this, c = r.findIndex((t => t.id.description === e)), l = new rs(this, e, a); if (c >= 0) { const t = this.item(c), e = t ? 1 : 0; t && !t.destroyed && t.destroy(!1), r.splice(c, e, l) } else r.push(l); const h = ((t, e) => { let s = e ?? document.getElementById(t); return s || (s = document.createElement("div"), s.id = t, s.dataset[i] = hs, document.body.append(s), s) })(e, t.element), d = (t => { let e; if (t instanceof HTMLCanvasElement || t.tagName.toLowerCase() === us) e = t, e.dataset[i] || (e.dataset[i] = ds); else { const o = t.getElementsByTagName(us); var s = !!o.length && o[0]; s && !s.id && !s.className ? e.dataset[i] = ds : (e = document.createElement(us), e.dataset[i] = hs, t.appendChild(e)) } const o = "100%"; return e.style.width || (e.style.width = o), e.style.height || (e.style.height = o), e })(h); return l.canvas.loadCanvas(d), await l.start(), l } loadOptions(t, e) { this.plugins.forEach((i => i.loadOptions?.(t, e))) } loadParticlesOptions(t, e, ...i) { const s = this.updaters.get(t); s && s.forEach((t => t.loadOptions?.(e, ...i))) } async refresh(t = !0) { t && await Promise.all(this.items.map((t => t.refresh()))) } removeEventListener(t, e) { this._eventDispatcher.removeEventListener(t, e) } setOnClickHandler(t) { const { items: e } = this; if (!e.length) throw new Error(`${f} can only set click handlers after calling tsParticles.load()`); e.forEach((e => e.addClickHandler(t))) } } var fs, ms, vs, ys, gs; !function (t) { t[t.h = 1] = "h", t[t.s = 2] = "s", t[t.l = 3] = "l", t[t.a = 5] = "a" }(fs || (fs = {})); class bs { constructor() { this.key = "hsl", this.stringPrefix = "hsl" } handleColor(t) { const e = t.value.hsl ?? t.value; if (void 0 !== e.h && void 0 !== e.s && void 0 !== e.l) return ee(e) } handleRangeColor(t) { const e = t.value.hsl ?? t.value; if (void 0 !== e.h && void 0 !== e.l) return ee({ h: U(e.h), l: U(e.l), s: U(e.s) }) } parseString(t) { if (!t.startsWith("hsl")) return; const e = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.%]+)\s*)?\)/i.exec(t); return e ? ie({ a: e.length > 4 ? it(e[fs.a]) : 1, h: parseInt(e[fs.h], 10), l: parseInt(e[fs.l], 10), s: parseInt(e[fs.s], 10) }) : void 0 } } !function (t) { t[t.r = 1] = "r", t[t.g = 2] = "g", t[t.b = 3] = "b", t[t.a = 5] = "a" }(ms || (ms = {})); class ws { constructor() { this.key = "rgb", this.stringPrefix = "rgb" } handleColor(t) { const e = t.value.rgb ?? t.value; if (void 0 !== e.r) return e } handleRangeColor(t) { const e = t.value.rgb ?? t.value; if (void 0 !== e.r) return { r: U(e.r), g: U(e.g), b: U(e.b) } } parseString(t) { if (!t.startsWith(this.stringPrefix)) return; const e = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.%]+)\s*)?\)/i.exec(t); return e ? { a: e.length > 4 ? it(e[ms.a]) : 1, b: parseInt(e[ms.b], 10), g: parseInt(e[ms.g], 10), r: parseInt(e[ms.r], 10) } : void 0 } } class xs { constructor(t) { this.type = Be.external, this.container = t } } class _s { constructor(t) { this.type = Be.particles, this.container = t } } !function (t) { t.clockwise = "clockwise", t.counterClockwise = "counter-clockwise", t.random = "random" }(vs || (vs = {})), function (t) { t.linear = "linear", t.radial = "radial", t.random = "random" }(ys || (ys = {})), function (t) { t.easeInBack = "ease-in-back", t.easeInCirc = "ease-in-circ", t.easeInCubic = "ease-in-cubic", t.easeInLinear = "ease-in-linear", t.easeInQuad = "ease-in-quad", t.easeInQuart = "ease-in-quart", t.easeInQuint = "ease-in-quint", t.easeInExpo = "ease-in-expo", t.easeInSine = "ease-in-sine", t.easeOutBack = "ease-out-back", t.easeOutCirc = "ease-out-circ", t.easeOutCubic = "ease-out-cubic", t.easeOutLinear = "ease-out-linear", t.easeOutQuad = "ease-out-quad", t.easeOutQuart = "ease-out-quart", t.easeOutQuint = "ease-out-quint", t.easeOutExpo = "ease-out-expo", t.easeOutSine = "ease-out-sine", t.easeInOutBack = "ease-in-out-back", t.easeInOutCirc = "ease-in-out-circ", t.easeInOutCubic = "ease-in-out-cubic", t.easeInOutLinear = "ease-in-out-linear", t.easeInOutQuad = "ease-in-out-quad", t.easeInOutQuart = "ease-in-out-quart", t.easeInOutQuint = "ease-in-out-quint", t.easeInOutExpo = "ease-in-out-expo", t.easeInOutSine = "ease-in-out-sine" }(gs || (gs = {})); const ks = function () { const t = new ws, e = new bs; Gt(t), Gt(e); const i = new ps; return i.init(), i }(); pt() || (window.tsParticles = ks); class Ps { constructor() { this.radius = 0, this.mass = 0 } load(t) { t && (void 0 !== t.mass && (this.mass = t.mass), void 0 !== t.radius && (this.radius = t.radius)) } } class zs extends ui { constructor() { super(), this.density = 5, this.value = 50, this.limit = new Ps } load(t) { t && (super.load(t), void 0 !== t.density && (this.density = t.density), x(t.limit) ? this.limit.radius = t.limit : this.limit.load(t.limit)) } } class Cs { constructor() { this.color = new Ve, this.color.value = "#000000", this.draggable = !1, this.opacity = 1, this.destroy = !0, this.orbits = !1, this.size = new zs } load(t) { void 0 !== t && (void 0 !== t.color && (this.color = Ve.create(this.color, t.color)), void 0 !== t.draggable && (this.draggable = t.draggable), this.name = t.name, void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.position && (this.position = {}, void 0 !== t.position.x && (this.position.x = j(t.position.x)), void 0 !== t.position.y && (this.position.y = j(t.position.y))), void 0 !== t.size && this.size.load(t.size), void 0 !== t.destroy && (this.destroy = t.destroy), void 0 !== t.orbits && (this.orbits = t.orbits)) } } var Ms; !function (t) { t.absorber = "absorber" }(Ms || (Ms = {})); const Os = 2 * Math.PI; class Ss { constructor(t, e, i, s) { this.absorbers = t, this.container = e, this._calcPosition = () => { const t = K({ size: this.container.canvas.size, position: this.options.position }); return C.create(t.x, t.y) }, this._updateParticlePosition = (t, e) => { if (t.destroyed) return; const i = this.container, s = i.canvas.size; if (t.needsNewPosition) { const e = J({ size: s }); t.position.setTo(e), t.velocity.setTo(t.initialVelocity), t.absorberOrbit = void 0, t.needsNewPosition = !1 } if (this.options.orbits) { if (void 0 === t.absorberOrbit && (t.absorberOrbit = C.origin, t.absorberOrbit.length = G(t.getPosition(), this.position), t.absorberOrbit.angle = I() * Os), t.absorberOrbit.length <= this.size && !this.options.destroy) { const e = Math.min(s.width, s.height), i = 1, o = .1, n = .2; t.absorberOrbit.length = e * (i + (I() * n - o)) } void 0 === t.absorberOrbitDirection && (t.absorberOrbitDirection = t.velocity.x >= 0 ? vs.clockwise : vs.counterClockwise); const o = t.absorberOrbit.length, n = t.absorberOrbit.angle, a = t.absorberOrbitDirection; t.velocity.setTo(C.origin); const r = { x: a === vs.clockwise ? Math.cos : Math.sin, y: a === vs.clockwise ? Math.sin : Math.cos }; t.position.x = this.position.x + o * r.x(n), t.position.y = this.position.y + o * r.y(n), t.absorberOrbit.length -= e.length, t.absorberOrbit.angle += (t.retina.moveSpeed ?? 0) * i.retina.pixelRatio / m * i.retina.reduceFactor } else { const i = C.origin; i.length = e.length, i.angle = e.angle, t.velocity.addTo(i) } }, this.initialPosition = s ? C.create(s.x, s.y) : void 0, i instanceof Cs ? this.options = i : (this.options = new Cs, this.options.load(i)), this.dragging = !1, this.name = this.options.name, this.opacity = this.options.opacity, this.size = U(this.options.size.value) * e.retina.pixelRatio, this.mass = this.size * this.options.size.density * e.retina.reduceFactor; const o = this.options.size.limit; this.limit = { radius: o.radius * e.retina.pixelRatio * e.retina.reduceFactor, mass: o.mass }, this.color = Qt(this.options.color) ?? { b: 0, g: 0, r: 0 }, this.position = this.initialPosition?.copy() ?? this._calcPosition() } attract(t) { const e = this.container, i = this.options; if (i.draggable) { const t = e.interactivity.mouse; t.clicking && t.downPosition ? G(this.position, t.downPosition) <= this.size && (this.dragging = !0) : this.dragging = !1, this.dragging && t.position && (this.position.x = t.position.x, this.position.y = t.position.y) } const s = t.getPosition(), { dx: o, dy: n, distance: a } = $(this.position, s), r = C.create(o, n); if (r.length = this.mass / Math.pow(a, 2) * e.retina.reduceFactor, a < this.size + t.getRadius()) { const s = .033 * t.getRadius() * e.retina.pixelRatio; this.size > t.getRadius() && a < this.size - t.getRadius() || void 0 !== t.absorberOrbit && t.absorberOrbit.length < 0 ? i.destroy ? t.destroy() : (t.needsNewPosition = !0, this._updateParticlePosition(t, r)) : (i.destroy && (t.size.value -= s), this._updateParticlePosition(t, r)), (this.limit.radius <= 0 || this.size < this.limit.radius) && (this.size += s), (this.limit.mass <= 0 || this.mass < this.limit.mass) && (this.mass += s * this.options.size.density * e.retina.reduceFactor) } else this._updateParticlePosition(t, r) } draw(t) { t.translate(this.position.x, this.position.y), t.beginPath(), t.arc(0, 0, this.size, 0, Os, !1), t.closePath(), t.fillStyle = oe(this.color, this.opacity), t.fill() } resize() { const t = this.initialPosition; this.position = t && _t(t, this.container.canvas.size, C.origin) ? t : this._calcPosition() } } class Ds { constructor(t) { this.container = t, this.array = [], this.absorbers = [], this.interactivityAbsorbers = [], t.getAbsorber = t => void 0 === t || x(t) ? this.array[t ?? 0] : this.array.find((e => e.name === t)), t.addAbsorber = async (t, e) => this.addAbsorber(t, e) } async addAbsorber(t, e) { const i = new Ss(this, this.container, t, e); return this.array.push(i), Promise.resolve(i) } draw(t) { for (const e of this.array) e.draw(t) } handleClickMode(t) { const e = this.absorbers, i = this.interactivityAbsorbers; if (t === Ms.absorber) { const t = It(i) ?? It(e), s = this.container.interactivity.mouse.clickPosition; this.addAbsorber(t, s) } } async init() { this.absorbers = this.container.actualOptions.absorbers, this.interactivityAbsorbers = this.container.actualOptions.interactivity.modes.absorbers; const t = Rt(this.absorbers, (async t => { await this.addAbsorber(t) })); t instanceof Array ? await Promise.all(t) : await t } particleUpdate(t) { for (const e of this.array) if (e.attract(t), t.destroyed) break } removeAbsorber(t) { const e = this.array.indexOf(t); e >= 0 && this.array.splice(e, 1) } resize() { for (const t of this.array) t.resize() } stop() { this.array = [] } } class Ts { constructor() { this.id = "absorbers" } async getPlugin(t) { return Promise.resolve(new Ds(t)) } loadOptions(t, e) { (this.needsPlugin(t) || this.needsPlugin(e)) && (e?.absorbers && (t.absorbers = Rt(e.absorbers, (t => { const e = new Cs; return e.load(t), e }))), t.interactivity.modes.absorbers = Rt(e?.interactivity?.modes?.absorbers, (t => { const e = new Cs; return e.load(t), e }))) } needsPlugin(t) { if (!t) return !1; const e = t.absorbers; return P(e) ? !!e.length : !!e || !(!t.interactivity?.events?.onClick?.mode || !gt(Ms.absorber, t.interactivity.events.onClick.mode)) } } class Es { load(t) { t && (void 0 !== t.bottom && (this.bottom = j(t.bottom)), void 0 !== t.left && (this.left = j(t.left)), void 0 !== t.right && (this.right = j(t.right)), void 0 !== t.top && (this.top = j(t.top))) } } var Rs; !function (t) { t.none = "none", t.split = "split" }(Rs || (Rs = {})); class Is extends ui { constructor() { super(), this.value = 3 } } class As extends ui { constructor() { super(), this.value = { min: 4, max: 9 } } } class Fs { constructor() { this.count = 1, this.factor = new Is, this.rate = new As, this.sizeOffset = !0 } load(t) { t && (void 0 !== t.color && (this.color = Ve.create(this.color, t.color)), void 0 !== t.count && (this.count = t.count), this.factor.load(t.factor), this.rate.load(t.rate), this.particles = Rt(t.particles, (t => zt({}, t))), void 0 !== t.sizeOffset && (this.sizeOffset = t.sizeOffset), t.colorOffset && (this.colorOffset = this.colorOffset ?? {}, void 0 !== t.colorOffset.h && (this.colorOffset.h = t.colorOffset.h), void 0 !== t.colorOffset.s && (this.colorOffset.s = t.colorOffset.s), void 0 !== t.colorOffset.l && (this.colorOffset.l = t.colorOffset.l))) } } class Ls { constructor() { this.bounds = new Es, this.mode = Rs.none, this.split = new Fs } load(t) { t && (t.mode && (this.mode = t.mode), t.bounds && this.bounds.load(t.bounds), this.split.load(t.split)) } } function Bs(t, e, i, s) { const o = i.options.destroy; if (!o) return; const n = o.split, a = Vi(t, e, i.options), r = U(n.factor.value), c = i.getFillColor(); n.color ? a.color.load(n.color) : n.colorOffset && c ? a.color.load({ value: { hsl: { h: c.h + U(n.colorOffset.h ?? 0), s: c.s + U(n.colorOffset.s ?? 0), l: c.l + U(n.colorOffset.l ?? 0) } } }) : a.color.load({ value: { hsl: i.getFillColor() } }), a.move.load({ center: { x: i.position.x, y: i.position.y, mode: rt.precise } }), x(a.size.value) ? a.size.value /= r : (a.size.value.min /= r, a.size.value.max /= r), a.load(s); const l = n.sizeOffset ? j(-i.size.value, i.size.value) : 0, h = { x: i.position.x + H(l), y: i.position.y + H(l) }; return e.particles.addParticle(h, a, i.group, (t => !(t.size.value < .5 || (t.velocity.length = H(j(i.velocity.length, t.velocity.length)), t.splitCount = (i.splitCount ?? 0) + 1, t.unbreakable = !0, setTimeout((() => { t.unbreakable = !1 }), 500), 0)))) } class qs { constructor(t, e) { this.container = e, this.engine = t } init(t) { const e = this.container, i = t.options.destroy; if (!i) return; t.splitCount = 0; const s = i.bounds; t.destroyBounds || (t.destroyBounds = {}); const { bottom: o, left: n, right: a, top: r } = s, { destroyBounds: c } = t, l = e.canvas.size; o && (c.bottom = U(o) * l.height / m), n && (c.left = U(n) * l.width / m), a && (c.right = U(a) * l.width / m), r && (c.top = U(r) * l.height / m) } isEnabled(t) { return !t.destroyed } loadOptions(t, ...e) { t.destroy || (t.destroy = new Ls); for (const i of e) t.destroy.load(i?.destroy) } particleDestroyed(t, e) { if (e) return; const i = t.options.destroy; i && i.mode === Rs.split && function (t, e, i) { const s = i.options.destroy; if (!s) return; const o = s.split; if (o.count >= 0 && (void 0 === i.splitCount || i.splitCount++ > o.count)) return; const n = U(o.rate.value), a = It(o.particles); for (let s = 0; s < n; s++)Bs(t, e, i, a) }(this.engine, this.container, t) } update(t) { if (!this.isEnabled(t)) return; const e = t.getPosition(), i = t.destroyBounds; i && (void 0 !== i.bottom && e.y >= i.bottom || void 0 !== i.left && e.x <= i.left || void 0 !== i.right && e.x >= i.right || void 0 !== i.top && e.y <= i.top) && t.destroy() } } class Hs { constructor() { this.wait = !1 } load(t) { t && (void 0 !== t.count && (this.count = t.count), void 0 !== t.delay && (this.delay = j(t.delay)), void 0 !== t.duration && (this.duration = j(t.duration)), void 0 !== t.wait && (this.wait = t.wait)) } } class Us { constructor() { this.quantity = 1, this.delay = .1 } load(t) { void 0 !== t && (void 0 !== t.quantity && (this.quantity = j(t.quantity)), void 0 !== t.delay && (this.delay = j(t.delay))) } } class Vs { constructor() { this.color = !1, this.opacity = !1 } load(t) { t && (void 0 !== t.color && (this.color = t.color), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class Ws { constructor() { this.options = {}, this.replace = new Vs, this.type = "square" } load(t) { t && (void 0 !== t.options && (this.options = zt({}, t.options ?? {})), this.replace.load(t.replace), void 0 !== t.type && (this.type = t.type)) } } class js { constructor() { this.mode = rt.percent, this.height = 0, this.width = 0 } load(t) { void 0 !== t && (void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.height && (this.height = t.height), void 0 !== t.width && (this.width = t.width)) } } class $s { constructor() { this.autoPlay = !0, this.fill = !0, this.life = new Hs, this.rate = new Us, this.shape = new Ws, this.startCount = 0 } load(t) { t && (void 0 !== t.autoPlay && (this.autoPlay = t.autoPlay), void 0 !== t.size && (this.size || (this.size = new js), this.size.load(t.size)), void 0 !== t.direction && (this.direction = t.direction), this.domId = t.domId, void 0 !== t.fill && (this.fill = t.fill), this.life.load(t.life), this.name = t.name, this.particles = Rt(t.particles, (t => zt({}, t))), this.rate.load(t.rate), this.shape.load(t.shape), void 0 !== t.position && (this.position = {}, void 0 !== t.position.x && (this.position.x = j(t.position.x)), void 0 !== t.position.y && (this.position.y = j(t.position.y))), void 0 !== t.spawnColor && (void 0 === this.spawnColor && (this.spawnColor = new li), this.spawnColor.load(t.spawnColor)), void 0 !== t.startCount && (this.startCount = t.startCount)) } } var Gs; function Ns(t, e) { t.color ? t.color.value = e : t.color = { value: e } } !function (t) { t.emitter = "emitter" }(Gs || (Gs = {})); class Qs { constructor(t, e, i, s, o) { this.emitters = e, this.container = i, this._destroy = () => { this._mutationObserver?.disconnect(), this._mutationObserver = void 0, this._resizeObserver?.disconnect(), this._resizeObserver = void 0, this.emitters.removeEmitter(this), this._engine.dispatchEvent("emitterDestroyed", { container: this.container, data: { emitter: this } }) }, this._prepareToDie = () => { if (this._paused) return; const t = void 0 !== this.options.life?.duration ? U(this.options.life.duration) : void 0; this.container.retina.reduceFactor && (this._lifeCount > 0 || this._immortal) && void 0 !== t && t > 0 && (this._duration = t * y) }, this._setColorAnimation = (t, e, i, s = 1) => { const o = this.container; if (!t.enable) return e; const n = H(t.offset), a = U(this.options.rate.delay) * y / o.retina.reduceFactor; return (e + U(t.speed ?? 0) * o.fpsLimit / a + n * s) % i }, this._engine = t, this._currentDuration = 0, this._currentEmitDelay = 0, this._currentSpawnDelay = 0, this._initialPosition = o, s instanceof $s ? this.options = s : (this.options = new $s, this.options.load(s)), this._spawnDelay = U(this.options.life.delay ?? 0) * y / this.container.retina.reduceFactor, this.position = this._initialPosition ?? this._calcPosition(), this.name = this.options.name, this.fill = this.options.fill, this._firstSpawn = !this.options.life.wait, this._startParticlesAdded = !1; let n = zt({}, this.options.particles); if (n ??= {}, n.move ??= {}, n.move.direction ??= this.options.direction, this.options.spawnColor && (this.spawnColor = Yt(this.options.spawnColor)), this._paused = !this.options.autoPlay, this._particlesOptions = n, this._size = this._calcSize(), this.size = qt(this._size, this.container.canvas.size), this._lifeCount = this.options.life.count ?? -1, this._immortal = this._lifeCount <= 0, this.options.domId) { const t = document.getElementById(this.options.domId); t && (this._mutationObserver = new MutationObserver((() => { this.resize() })), this._resizeObserver = new ResizeObserver((() => { this.resize() })), this._mutationObserver.observe(t, { attributes: !0, attributeFilter: ["style", "width", "height"] }), this._resizeObserver.observe(t)) } const a = this.options.shape, r = this._engine.emitterShapeManager?.getShapeGenerator(a.type); r && (this._shape = r.generate(this.position, this.size, this.fill, a.options)), this._engine.dispatchEvent("emitterCreated", { container: i, data: { emitter: this } }), this.play() } externalPause() { this._paused = !0, this.pause() } externalPlay() { this._paused = !1, this.play() } async init() { await (this._shape?.init()) } pause() { this._paused || delete this._emitDelay } play() { if (!this._paused && this.container.retina.reduceFactor && (this._lifeCount > 0 || this._immortal || !this.options.life.count) && (this._firstSpawn || this._currentSpawnDelay >= (this._spawnDelay ?? 0))) { if (void 0 === this._emitDelay) { const t = U(this.options.rate.delay); this._emitDelay = t * y / this.container.retina.reduceFactor } (this._lifeCount > 0 || this._immortal) && this._prepareToDie() } } resize() { const t = this._initialPosition; this.position = t && _t(t, this.container.canvas.size, C.origin) ? t : this._calcPosition(), this._size = this._calcSize(), this.size = qt(this._size, this.container.canvas.size), this._shape?.resize(this.position, this.size) } update(t) { this._paused || (this._firstSpawn && (this._firstSpawn = !1, this._currentSpawnDelay = this._spawnDelay ?? 0, this._currentEmitDelay = this._emitDelay ?? 0), this._startParticlesAdded || (this._startParticlesAdded = !0, this._emitParticles(this.options.startCount)), void 0 !== this._duration && (this._currentDuration += t.value, this._currentDuration >= this._duration && (this.pause(), void 0 !== this._spawnDelay && delete this._spawnDelay, this._immortal || this._lifeCount--, this._lifeCount > 0 || this._immortal ? (this.position = this._calcPosition(), this._shape?.resize(this.position, this.size), this._spawnDelay = U(this.options.life.delay ?? 0) * y / this.container.retina.reduceFactor) : this._destroy(), this._currentDuration -= this._duration, delete this._duration)), void 0 !== this._spawnDelay && (this._currentSpawnDelay += t.value, this._currentSpawnDelay >= this._spawnDelay && (this._engine.dispatchEvent("emitterPlay", { container: this.container }), this.play(), this._currentSpawnDelay -= this._currentSpawnDelay, delete this._spawnDelay)), void 0 !== this._emitDelay && (this._currentEmitDelay += t.value, this._currentEmitDelay >= this._emitDelay && (this._emit(), this._currentEmitDelay -= this._emitDelay))) } _calcPosition() { if (this.options.domId) { const t = document.getElementById(this.options.domId); if (t) { const e = t.getBoundingClientRect(), i = this.container.retina.pixelRatio; return { x: (e.x + .5 * e.width) * i, y: (e.y + .5 * e.height) * i } } } return K({ size: this.container.canvas.size, position: this.options.position }) } _calcSize() { const t = this.container; if (this.options.domId) { const e = document.getElementById(this.options.domId); if (e) { const i = e.getBoundingClientRect(); return { width: i.width * t.retina.pixelRatio, height: i.height * t.retina.pixelRatio, mode: rt.precise } } } return this.options.size ?? (() => { const t = new js; return t.load({ height: 0, mode: rt.percent, width: 0 }), t })() } _emit() { if (this._paused) return; const t = U(this.options.rate.quantity); this._emitParticles(t) } _emitParticles(t) { const e = It(this._particlesOptions); for (let i = 0; i < t; i++) { const t = zt({}, e); if (this.spawnColor) { const e = this.options.spawnColor?.animation; if (e) { const t = { h: 360, s: 100, l: 100 }, i = 3.6; this.spawnColor.h = this._setColorAnimation(e.h, this.spawnColor.h, t.h, i), this.spawnColor.s = this._setColorAnimation(e.s, this.spawnColor.s, t.s), this.spawnColor.l = this._setColorAnimation(e.l, this.spawnColor.l, t.l) } Ns(t, this.spawnColor) } const i = this.options.shape; let s = this.position; if (this._shape) { const e = this._shape.randomPosition(); if (e) { s = e.position; const o = i.replace; o.color && e.color && Ns(t, e.color), o.opacity && (t.opacity ? t.opacity.value = e.opacity : t.opacity = { value: e.opacity }) } else s = null } s && this.container.particles.addParticle(s, t) } } } class Zs { constructor(t, e) { this.container = e, this._engine = t, this.array = [], this.emitters = [], this.interactivityEmitters = { random: { count: 1, enable: !1 }, value: [] }, e.getEmitter = t => void 0 === t || x(t) ? this.array[t ?? 0] : this.array.find((e => e.name === t)), e.addEmitter = async (t, e) => this.addEmitter(t, e), e.removeEmitter = t => { const i = e.getEmitter(t); i && this.removeEmitter(i) }, e.playEmitter = t => { const i = e.getEmitter(t); i && i.externalPlay() }, e.pauseEmitter = t => { const i = e.getEmitter(t); i && i.externalPause() } } async addEmitter(t, e) { const i = new $s; i.load(t); const s = new Qs(this._engine, this, this.container, i, e); return await s.init(), this.array.push(s), s } handleClickMode(t) { const e = this.emitters, i = this.interactivityEmitters; if (t !== Gs.emitter) return; let s; if (i && P(i.value)) { const t = 0; if (i.value.length > t && i.random.enable) { s = []; const t = []; for (let e = 0; e < i.random.count; e++) { const o = wt(i.value); t.includes(o) && t.length < i.value.length ? e-- : (t.push(o), s.push(xt(i.value, o))) } } else s = i.value } else s = i?.value; const o = s ?? e, n = this.container.interactivity.mouse.clickPosition; Rt(o, (async t => { await this.addEmitter(t, n) })) } async init() { if (this.emitters = this.container.actualOptions.emitters, this.interactivityEmitters = this.container.actualOptions.interactivity.modes.emitters, this.emitters) if (P(this.emitters)) for (const t of this.emitters) await this.addEmitter(t); else await this.addEmitter(this.emitters) } pause() { for (const t of this.array) t.pause() } play() { for (const t of this.array) t.play() } removeEmitter(t) { const e = this.array.indexOf(t); e >= 0 && this.array.splice(e, 1) } resize() { for (const t of this.array) t.resize() } stop() { this.array = [] } update(t) { for (const e of this.array) e.update(t) } } class Xs { constructor(t) { this._engine = t, this.id = "emitters" } getPlugin(t) { return Promise.resolve(new Zs(this._engine, t)) } loadOptions(t, e) { if (!this.needsPlugin(t) && !this.needsPlugin(e)) return; e?.emitters && (t.emitters = Rt(e.emitters, (t => { const e = new $s; return e.load(t), e }))); const i = e?.interactivity?.modes?.emitters; if (i) if (P(i)) t.interactivity.modes.emitters = { random: { count: 1, enable: !0 }, value: i.map((t => { const e = new $s; return e.load(t), e })) }; else { const e = i; if (void 0 !== e.value) { const i = 1; if (P(e.value)) t.interactivity.modes.emitters = { random: { count: e.random.count ?? i, enable: e.random.enable ?? !1 }, value: e.value.map((t => { const e = new $s; return e.load(t), e })) }; else { const s = new $s; s.load(e.value), t.interactivity.modes.emitters = { random: { count: e.random.count ?? i, enable: e.random.enable ?? !1 }, value: s } } } else (t.interactivity.modes.emitters = { random: { count: 1, enable: !1 }, value: new $s }).value.load(i) } } needsPlugin(t) { if (!t) return !1; const e = t.emitters; return P(e) && !!e.length || void 0 !== e || !!t.interactivity?.events?.onClick?.mode && gt(Gs.emitter, t.interactivity.events.onClick.mode) } } const Ys = new Map; class Js { constructor(t) { this._engine = t } addShapeGenerator(t, e) { this.getShapeGenerator(t) || Ys.set(t, e) } getShapeGenerator(t) { return Ys.get(t) } getSupportedShapeGenerators() { return Ys.keys() } } class Ks { constructor(t, e, i, s) { this.position = t, this.size = e, this.fill = i, this.options = s } resize(t, e) { this.position = t, this.size = e } } const to = 2 * Math.PI; class eo extends Ks { constructor(t, e, i, s) { super(t, e, i, s) } async init() { } randomPosition() { const t = this.size, e = this.fill, i = this.position, [s, o] = [.5 * t.width, .5 * t.height], n = ((t, e) => { const i = .25 * I(), s = Math.atan(e / t * Math.tan(to * i)), o = I(); return o < .25 ? s : o < .5 ? Math.PI - s : o < .75 ? Math.PI + s : -s })(s, o), a = (h = n, (c = s) * (l = o) / Math.sqrt((l * Math.cos(h)) ** 2 + (c * Math.sin(h)) ** 2)), r = e ? a * Math.sqrt(I()) : a; var c, l, h; return { position: { x: i.x + r * Math.cos(n), y: i.y + r * Math.sin(n) } } } } class io { generate(t, e, i, s) { return new eo(t, e, i, s) } } var so; function oo(t, e) { return t + e * (I() - v) } !function (t) { t[t.TopLeft = 0] = "TopLeft", t[t.TopRight = 1] = "TopRight", t[t.BottomRight = 2] = "BottomRight", t[t.BottomLeft = 3] = "BottomLeft" }(so || (so = {})); class no extends Ks { constructor(t, e, i, s) { super(t, e, i, s) } async init() { } randomPosition() { const t = this.fill, e = this.position, i = this.size; if (t) return { position: { x: oo(e.x, i.width), y: oo(e.y, i.height) } }; { const t = .5 * i.width, s = .5 * i.height, o = Math.floor(4 * I()), n = 2 * (I() - v); switch (o) { case so.TopLeft: return { position: { x: e.x + n * t, y: e.y - s } }; case so.TopRight: return { position: { x: e.x - t, y: e.y + n * s } }; case so.BottomRight: return { position: { x: e.x + n * t, y: e.y + s } }; case so.BottomLeft: default: return { position: { x: e.x + t, y: e.y + n * s } } } } } } class ao { generate(t, e, i, s) { return new no(t, e, i, s) } } class ro { constructor() { this.delay = 1, this.pauseOnStop = !1, this.quantity = 1 } load(t) { t && (void 0 !== t.delay && (this.delay = t.delay), void 0 !== t.quantity && (this.quantity = t.quantity), void 0 !== t.particles && (this.particles = zt({}, t.particles)), void 0 !== t.pauseOnStop && (this.pauseOnStop = t.pauseOnStop)) } } const co = "trail"; class lo extends xs { constructor(t) { super(t), this._delay = 0 } clear() { } init() { } interact(t) { const e = this.container, { interactivity: i } = e; if (!e.retina.reduceFactor) return; const s = e.actualOptions.interactivity.modes.trail; if (!s) return; const o = s.delay * y / this.container.retina.reduceFactor; if (this._delay < o && (this._delay += t.value), this._delay < o) return; const n = !(s.pauseOnStop && (i.mouse.position === this._lastPosition || i.mouse.position?.x === this._lastPosition?.x && i.mouse.position?.y === this._lastPosition?.y)), a = e.interactivity.mouse.position; a ? this._lastPosition = { ...a } : delete this._lastPosition, n && e.particles.push(s.quantity, e.interactivity.mouse, s.particles), this._delay -= o } isEnabled(t) { const e = this.container, i = e.actualOptions, s = e.interactivity.mouse, o = (t?.interactivity ?? i.interactivity).events; return s.clicking && s.inside && !!s.position && gt(co, o.onClick.mode) || s.inside && !!s.position && gt(co, o.onHover.mode) } loadModeOptions(t, ...e) { t.trail || (t.trail = new ro); for (const i of e) t.trail.load(i?.trail) } reset() { } } var ho; !function (t) { t.both = "both", t.horizontal = "horizontal", t.vertical = "vertical" }(ho || (ho = {})); const uo = 2 * Math.PI; class po { constructor() { this.enable = !1, this.value = 0 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.value && (this.value = j(t.value))) } } class fo { constructor() { this.darken = new po, this.enable = !1, this.enlighten = new po, this.mode = ho.vertical, this.speed = 25 } load(t) { t && (void 0 !== t.backColor && (this.backColor = Ve.create(this.backColor, t.backColor)), this.darken.load(t.darken), void 0 !== t.enable && (this.enable = t.enable), this.enlighten.load(t.enlighten), void 0 !== t.mode && (this.mode = t.mode), void 0 !== t.speed && (this.speed = j(t.speed))) } } class mo { getTransformValues(t) { const e = t.roll?.enable && t.roll, i = e && e.horizontal, s = e && e.vertical; return { a: i ? Math.cos(e.angle) : void 0, d: s ? Math.sin(e.angle) : void 0 } } init(t) { !function (t) { const e = t.options.roll; if (e?.enable) if (t.roll = { enable: e.enable, horizontal: e.mode === ho.horizontal || e.mode === ho.both, vertical: e.mode === ho.vertical || e.mode === ho.both, angle: I() * uo, speed: U(e.speed) / 360 }, e.backColor) t.backColor = Yt(e.backColor); else if (e.darken.enable && e.enlighten.enable) { const i = I() >= v ? Ut.darken : Ut.enlighten; t.roll.alter = { type: i, value: U(i === Ut.darken ? e.darken.value : e.enlighten.value) } } else e.darken.enable ? t.roll.alter = { type: Ut.darken, value: U(e.darken.value) } : e.enlighten.enable && (t.roll.alter = { type: Ut.enlighten, value: U(e.enlighten.value) }); else t.roll = { enable: !1, horizontal: !1, vertical: !1, angle: 0, speed: 0 } }(t) } isEnabled(t) { const e = t.options.roll; return !t.destroyed && !t.spawning && !!e?.enable } loadOptions(t, ...e) { t.roll || (t.roll = new fo); for (const i of e) t.roll.load(i?.roll) } update(t, e) { this.isEnabled(t) && function (t, e) { const i = t.options.roll, s = t.roll; if (!s || !i?.enable) return; const o = s.speed * e.factor, n = uo; s.angle += o, s.angle > n && (s.angle -= n) }(t, e) } } class vo { init(t) { const e = t.options.move.gravity; t.gravity = { enable: e.enable, acceleration: U(e.acceleration), inverse: e.inverse }, function (t) { const e = t.container, i = t.options.move.spin; if (!i.enable) return; const s = i.position ?? { x: 50, y: 50 }, o = { x: .01 * s.x * e.canvas.size.width, y: .01 * s.y * e.canvas.size.height }, n = G(t.getPosition(), o), a = U(i.acceleration); t.retina.spinAcceleration = a * e.retina.pixelRatio, t.spin = { center: o, direction: t.velocity.x >= 0 ? vs.clockwise : vs.counterClockwise, angle: t.velocity.angle, radius: n, acceleration: t.retina.spinAcceleration } }(t) } isEnabled(t) { return !t.destroyed && t.options.move.enable } move(t, e) { const i = t.options, s = i.move; if (!s.enable) return; const o = t.container, n = o.retina.pixelRatio; t.retina.moveSpeed ??= U(s.speed) * n, t.retina.moveDrift ??= U(t.options.move.drift) * n; const a = function (t) { return t.slow.inRange ? t.slow.factor : 1 }(t), r = t.retina.moveSpeed * o.retina.reduceFactor, c = t.retina.moveDrift, l = W(i.size.value) * n, h = r * (s.size ? t.getRadius() / l : 1) * a * (e.factor || 1) / 2, d = t.retina.maxSpeed ?? o.retina.maxSpeed; s.spin.enable ? function (t, e) { const i = t.container; if (!t.spin) return; const s = { x: t.spin.direction === vs.clockwise ? Math.cos : Math.sin, y: t.spin.direction === vs.clockwise ? Math.sin : Math.cos }; t.position.x = t.spin.center.x + t.spin.radius * s.x(t.spin.angle), t.position.y = t.spin.center.y + t.spin.radius * s.y(t.spin.angle), t.spin.radius += t.spin.acceleration; const o = Math.max(i.canvas.size.width, i.canvas.size.height), n = .5 * o; t.spin.radius > n ? (t.spin.radius = n, t.spin.acceleration *= -1) : t.spin.radius < 0 && (t.spin.radius = 0, t.spin.acceleration *= -1), t.spin.angle += .01 * e * (1 - t.spin.radius / o) }(t, h) : function (t, e, i, s, o, n) { !function (t, e) { const i = t.options.move.path; if (!i.enable) return; if (t.lastPathTime <= t.pathDelay) return void (t.lastPathTime += e.value); const s = t.pathGenerator?.generate(t, e); s && t.velocity.addTo(s), i.clamp && (t.velocity.x = B(t.velocity.x, -1, 1), t.velocity.y = B(t.velocity.y, -1, 1)), t.lastPathTime -= t.pathDelay }(t, n); const a = t.gravity, r = a?.enable && a.inverse ? -1 : 1; o && i && (t.velocity.x += o * n.factor / (60 * i)), a?.enable && i && (t.velocity.y += r * (a.acceleration * n.factor) / (60 * i)); const c = t.moveDecay; t.velocity.multTo(c); const l = t.velocity.mult(i); a?.enable && s > 0 && (!a.inverse && l.y >= 0 && l.y >= s || a.inverse && l.y <= 0 && l.y <= -s) && (l.y = r * s, i && (t.velocity.y = l.y / i)); const h = t.options.zIndex, d = (1 - t.zIndexFactor) ** h.velocityRate; l.multTo(d); const { position: u } = t; u.addTo(l), e.vibrate && (u.x += Math.sin(u.x * Math.cos(u.y)), u.y += Math.cos(u.y * Math.sin(u.x))) }(t, s, h, d, c, e), function (t) { const e = t.initialPosition, { dx: i, dy: s } = $(e, t.position), o = Math.abs(i), n = Math.abs(s), { maxDistance: a } = t.retina, r = a.horizontal, c = a.vertical; if (r || c) if ((r && o >= r || c && n >= c) && !t.misplaced) t.misplaced = !!r && o > r || !!c && n > c, r && (t.velocity.x = .5 * t.velocity.y - t.velocity.x), c && (t.velocity.y = .5 * t.velocity.x - t.velocity.y); else if ((!r || o < r) && (!c || n < c) && t.misplaced) t.misplaced = !1; else if (t.misplaced) { const i = t.position, s = t.velocity; r && (i.x < e.x && s.x < 0 || i.x > e.x && s.x > 0) && (s.x *= -I()), c && (i.y < e.y && s.y < 0 || i.y > e.y && s.y > 0) && (s.y *= -I()) } }(t) } } const yo = 2 * Math.PI; class go { constructor() { this.validTypes = ["circle"] } draw(t) { !function (t) { const { context: e, particle: i, radius: s } = t; i.circleRange || (i.circleRange = { min: 0, max: yo }); const o = i.circleRange; e.arc(0, 0, s, o.min, o.max, !1) }(t) } getSidesCount() { return 12 } particleInit(t, e) { const i = e.shapeData, s = i?.angle ?? { max: 360, min: 0 }; e.circleRange = k(s) ? { min: N(s.min), max: N(s.max) } : { min: 0, max: N(s) } } } class bo { constructor(t) { this.container = t } init(t) { const e = Yt(t.options.color, t.id, t.options.reduceDuplicates); e && (t.color = he(e, t.options.color.animation, this.container.retina.reduceFactor)) } isEnabled(t) { const { h: e, s: i, l: s } = t.options.color.animation, { color: o } = t; return !t.destroyed && !t.spawning && (void 0 !== o?.h.value && e.enable || void 0 !== o?.s.value && i.enable || void 0 !== o?.l.value && s.enable) } update(t, e) { pe(t.color, e) } } class wo { constructor(t) { this.container = t } init(t) { const e = t.options.opacity; t.opacity = Ft(e, 1); const i = e.animation; i.enable && (t.opacity.velocity = U(i.speed) / m * this.container.retina.reduceFactor, i.sync || (t.opacity.velocity *= I())) } isEnabled(t) { return !t.destroyed && !t.spawning && !!t.opacity && t.opacity.enable && ((t.opacity.maxLoops ?? 0) <= 0 || (t.opacity.maxLoops ?? 0) > 0 && (t.opacity.loops ?? 0) < (t.opacity.maxLoops ?? 0)) } reset(t) { t.opacity && (t.opacity.time = 0, t.opacity.loops = 0) } update(t, e) { this.isEnabled(t) && t.opacity && Ht(t, t.opacity, !0, t.options.opacity.animation.destroy, e) } } class xo { constructor(t) { this.container = t, this.modes = [Fe.bounce, Fe.split] } update(t, e, i, s) { if (!this.modes.includes(s)) return; const o = this.container; let n = !1; for (const [, s] of o.plugins) if (void 0 !== s.particleBounce && (n = s.particleBounce(t, i, e)), n) break; if (n) return; const a = t.getPosition(), r = t.offset, c = t.getRadius(), l = Pt(a, c), h = o.canvas.size; !function (t) { if (t.outMode !== Fe.bounce && t.outMode !== Fe.split || t.direction !== at.left && t.direction !== at.right) return; t.bounds.right < 0 && t.direction === at.left ? t.particle.position.x = t.size + t.offset.x : t.bounds.left > t.canvasSize.width && t.direction === at.right && (t.particle.position.x = t.canvasSize.width - t.size - t.offset.x); const e = t.particle.velocity.x; let i = !1; if (t.direction === at.right && t.bounds.right >= t.canvasSize.width && e > 0 || t.direction === at.left && t.bounds.left <= 0 && e < 0) { const e = U(t.particle.options.bounce.horizontal.value); t.particle.velocity.x *= -e, i = !0 } if (!i) return; const s = t.offset.x + t.size; t.bounds.right >= t.canvasSize.width && t.direction === at.right ? t.particle.position.x = t.canvasSize.width - s : t.bounds.left <= 0 && t.direction === at.left && (t.particle.position.x = s), t.outMode === Fe.split && t.particle.destroy() }({ particle: t, outMode: s, direction: e, bounds: l, canvasSize: h, offset: r, size: c }), function (t) { if (t.outMode !== Fe.bounce && t.outMode !== Fe.split || t.direction !== at.bottom && t.direction !== at.top) return; t.bounds.bottom < 0 && t.direction === at.top ? t.particle.position.y = t.size + t.offset.y : t.bounds.top > t.canvasSize.height && t.direction === at.bottom && (t.particle.position.y = t.canvasSize.height - t.size - t.offset.y); const e = t.particle.velocity.y; let i = !1; if (t.direction === at.bottom && t.bounds.bottom >= t.canvasSize.height && e > 0 || t.direction === at.top && t.bounds.top <= 0 && e < 0) { const e = U(t.particle.options.bounce.vertical.value); t.particle.velocity.y *= -e, i = !0 } if (!i) return; const s = t.offset.y + t.size; t.bounds.bottom >= t.canvasSize.height && t.direction === at.bottom ? t.particle.position.y = t.canvasSize.height - s : t.bounds.top <= 0 && t.direction === at.top && (t.particle.position.y = s), t.outMode === Fe.split && t.particle.destroy() }({ particle: t, outMode: s, direction: e, bounds: l, canvasSize: h, offset: r, size: c }) } } class _o { constructor(t) { this.container = t, this.modes = [Fe.destroy] } update(t, e, i, s) { if (!this.modes.includes(s)) return; const o = this.container; switch (t.outType) { case qe.normal: case qe.outside: if (_t(t.position, o.canvas.size, C.origin, t.getRadius(), e)) return; break; case qe.inside: { const { dx: e, dy: i } = $(t.position, t.moveCenter), { x: s, y: o } = t.velocity; if (s < 0 && e > t.moveCenter.radius || o < 0 && i > t.moveCenter.radius || s >= 0 && e < -t.moveCenter.radius || o >= 0 && i < -t.moveCenter.radius) return; break } }o.particles.remove(t, void 0, !0) } } class ko { constructor(t) { this.container = t, this.modes = [Fe.none] } update(t, e, i, s) { if (!this.modes.includes(s)) return; if ((t.options.move.distance.horizontal && (e === at.left || e === at.right)) ?? (t.options.move.distance.vertical && (e === at.top || e === at.bottom))) return; const o = t.options.move.gravity, n = this.container, a = n.canvas.size, r = t.getRadius(); if (o.enable) { const i = t.position; (!o.inverse && i.y > a.height + r && e === at.bottom || o.inverse && i.y < -r && e === at.top) && n.particles.remove(t) } else { if (t.velocity.y > 0 && t.position.y <= a.height + r || t.velocity.y < 0 && t.position.y >= -r || t.velocity.x > 0 && t.position.x <= a.width + r || t.velocity.x < 0 && t.position.x >= -r) return; _t(t.position, n.canvas.size, C.origin, r, e) || n.particles.remove(t) } } } class Po { constructor(t) { this.container = t, this.modes = [Fe.out] } update(t, e, i, s) { if (!this.modes.includes(s)) return; const o = this.container; switch (t.outType) { case qe.inside: { const { x: e, y: i } = t.velocity, s = C.origin; s.length = t.moveCenter.radius, s.angle = t.velocity.angle + Math.PI, s.addTo(C.create(t.moveCenter)); const { dx: n, dy: a } = $(t.position, s); if (e <= 0 && n >= 0 || i <= 0 && a >= 0 || e >= 0 && n <= 0 || i >= 0 && a <= 0) return; t.position.x = Math.floor(H({ min: 0, max: o.canvas.size.width })), t.position.y = Math.floor(H({ min: 0, max: o.canvas.size.height })); const { dx: r, dy: c } = $(t.position, t.moveCenter); t.direction = Math.atan2(-c, -r), t.velocity.angle = t.direction; break } default: if (_t(t.position, o.canvas.size, C.origin, t.getRadius(), e)) return; switch (t.outType) { case qe.outside: { t.position.x = Math.floor(H({ min: -t.moveCenter.radius, max: t.moveCenter.radius })) + t.moveCenter.x, t.position.y = Math.floor(H({ min: -t.moveCenter.radius, max: t.moveCenter.radius })) + t.moveCenter.y; const { dx: e, dy: i } = $(t.position, t.moveCenter); t.moveCenter.radius && (t.direction = Math.atan2(i, e), t.velocity.angle = t.direction); break } case qe.normal: { const i = t.options.move.warp, s = o.canvas.size, n = { bottom: s.height + t.getRadius() + t.offset.y, left: -t.getRadius() - t.offset.x, right: s.width + t.getRadius() + t.offset.x, top: -t.getRadius() - t.offset.y }, a = t.getRadius(), r = Pt(t.position, a); e === at.right && r.left > s.width + t.offset.x ? (t.position.x = n.left, t.initialPosition.x = t.position.x, i || (t.position.y = I() * s.height, t.initialPosition.y = t.position.y)) : e === at.left && r.right < -t.offset.x && (t.position.x = n.right, t.initialPosition.x = t.position.x, i || (t.position.y = I() * s.height, t.initialPosition.y = t.position.y)), e === at.bottom && r.top > s.height + t.offset.y ? (i || (t.position.x = I() * s.width, t.initialPosition.x = t.position.x), t.position.y = n.top, t.initialPosition.y = t.position.y) : e === at.top && r.bottom < -t.offset.y && (i || (t.position.x = I() * s.width, t.initialPosition.x = t.position.x), t.position.y = n.bottom, t.initialPosition.y = t.position.y); break } } } } } const zo = (t, e) => t.default === e || t.bottom === e || t.left === e || t.right === e || t.top === e; class Co { constructor(t) { this._updateOutMode = (t, e, i, s) => { for (const o of this.updaters) o.update(t, s, e, i) }, this.container = t, this.updaters = [] } init(t) { this.updaters = []; const e = t.options.move.outModes; zo(e, Fe.bounce) ? this.updaters.push(new xo(this.container)) : zo(e, Fe.out) ? this.updaters.push(new Po(this.container)) : zo(e, Fe.destroy) ? this.updaters.push(new _o(this.container)) : zo(e, Fe.none) && this.updaters.push(new ko(this.container)) } isEnabled(t) { return !t.destroyed && !t.spawning } update(t, e) { const i = t.options.move.outModes; this._updateOutMode(t, e, i.bottom ?? i.default, at.bottom), this._updateOutMode(t, e, i.left ?? i.default, at.left), this._updateOutMode(t, e, i.right ?? i.default, at.right), this._updateOutMode(t, e, i.top ?? i.default, at.top) } } class Mo { init(t) { const e = t.container, i = t.options.size.animation; i.enable && (t.size.velocity = (t.retina.sizeAnimationSpeed ?? e.retina.sizeAnimationSpeed) / m * e.retina.reduceFactor, i.sync || (t.size.velocity *= I())) } isEnabled(t) { return !t.destroyed && !t.spawning && t.size.enable && ((t.size.maxLoops ?? 0) <= 0 || (t.size.maxLoops ?? 0) > 0 && (t.size.loops ?? 0) < (t.size.maxLoops ?? 0)) } reset(t) { t.size.loops = 0 } update(t, e) { this.isEnabled(t) && Ht(t, t.size, !0, t.options.size.animation.destroy, e) } } const Oo = '"Twemoji Mozilla", Apple Color Emoji, "Segoe UI Emoji", "Noto Color Emoji", "EmojiOne Color"'; class So { constructor() { this.validTypes = ["emoji"], this._emojiShapeDict = new Map } destroy() { for (const [t, e] of this._emojiShapeDict) e instanceof ImageBitmap && (e?.close(), this._emojiShapeDict.delete(t)) } draw(t) { !function (t) { const { context: e, particle: i, radius: s, opacity: o } = t, n = i.emojiData, a = 2 * s, r = e.globalAlpha; n && (e.globalAlpha = o, e.drawImage(n, -s, -s, a, a), e.globalAlpha = r) }(t) } async init(t) { const e = t.actualOptions, { validTypes: i } = this; if (!i.find((t => gt(t, e.particles.shape.type)))) return; const s = [bt(Oo)], o = i.map((t => e.particles.shape.options[t])).find((t => !!t)); o && Rt(o, (t => { t.font && s.push(bt(t.font)) })), await Promise.all(s) } particleDestroy(t) { delete t.emojiData } particleInit(t, e) { const i = e.shapeData; if (!i?.value) return; const s = It(i.value, e.randomIndexData), o = i.font ?? Oo; if (!s) return; const n = `${s}_${o}`, a = this._emojiShapeDict.get(n); if (a) return void (e.emojiData = a); const r = 2 * W(e.size.value); let c; const l = W(e.size.value); if ("undefined" != typeof OffscreenCanvas) { const t = new OffscreenCanvas(r, r), e = t.getContext("2d"); if (!e) return; e.font = `400 ${2 * l}px ${o}`, e.textBaseline = "middle", e.textAlign = "center", e.fillText(s, l, l), c = t.transferToImageBitmap() } else { const t = document.createElement("canvas"); t.width = r, t.height = r; const e = t.getContext("2d"); if (!e) return; e.font = `400 ${2 * l}px ${o}`, e.textBaseline = "middle", e.textAlign = "center", e.fillText(s, l, l), c = t } this._emojiShapeDict.set(n, c), e.emojiData = c } } function Do(t, e, i, s, o) { const n = t.actualOptions.interactivity.modes.attract; if (!n) return; const a = t.particles.quadTree.query(s, o); for (const t of a) { const { dx: s, dy: o, distance: a } = $(t.position, e), r = n.speed * n.factor, c = B(E(n.easing)(1 - a / i) * r, 1, n.maxSpeed), l = C.create(a ? s / a * c : r, a ? o / a * c : r); t.position.subFrom(l) } } class To { constructor() { this.distance = 200, this.duration = .4, this.easing = gs.easeOutQuad, this.factor = 1, this.maxSpeed = 50, this.speed = 1 } load(t) { t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.easing && (this.easing = t.easing), void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.maxSpeed && (this.maxSpeed = t.maxSpeed), void 0 !== t.speed && (this.speed = t.speed)) } } const Eo = "attract"; class Ro extends xs { constructor(t, e) { super(e), this._engine = t, e.attract || (e.attract = { particles: [] }), this.handleClickMode = t => { const i = this.container.actualOptions.interactivity.modes.attract; if (i && t === Eo) { e.attract || (e.attract = { particles: [] }), e.attract.clicking = !0, e.attract.count = 0; for (const t of e.attract.particles) this.isEnabled(t) && t.velocity.setTo(t.initialVelocity); e.attract.particles = [], e.attract.finish = !1, setTimeout((() => { e.destroyed || (e.attract || (e.attract = { particles: [] }), e.attract.clicking = !1) }), i.duration * y) } } } clear() { } init() { const t = this.container, e = t.actualOptions.interactivity.modes.attract; e && (t.retina.attractModeDistance = e.distance * t.retina.pixelRatio) } interact() { const t = this.container, e = t.actualOptions, i = t.interactivity.status === r, s = e.interactivity.events, { enable: o, mode: n } = s.onHover, { enable: a, mode: c } = s.onClick; i && o && gt(Eo, n) ? function (t, e) { const i = t.interactivity.mouse.position, s = t.retina.attractModeDistance; !s || s < 0 || !i || Do(t, i, s, new Ji(i.x, i.y, s), (t => e(t))) }(this.container, (t => this.isEnabled(t))) : a && gt(Eo, c) && function (t, e) { t.attract || (t.attract = { particles: [] }); const { attract: i } = t; if (i.finish || (i.count || (i.count = 0), i.count++, i.count === t.particles.count && (i.finish = !0)), i.clicking) { const i = t.interactivity.mouse.clickPosition, s = t.retina.attractModeDistance; if (!s || s < 0 || !i) return; Do(t, i, s, new Ji(i.x, i.y, s), (t => e(t))) } else !1 === i.clicking && (i.particles = []) }(this.container, (t => this.isEnabled(t))) } isEnabled(t) { const e = this.container, i = e.actualOptions, s = e.interactivity.mouse, o = (t?.interactivity ?? i.interactivity).events; if (!(s.position && o.onHover.enable || s.clickPosition && o.onClick.enable)) return !1; const n = o.onHover.mode, a = o.onClick.mode; return gt(Eo, n) || gt(Eo, a) } loadModeOptions(t, ...e) { t.attract || (t.attract = new To); for (const i of e) t.attract.load(i?.attract) } reset() { } } const Io = 2, Ao = .5, Fo = Math.PI * Ao; function Lo(t, e, i, s, o) { const n = t.particles.quadTree.query(s, o); for (const t of n) s instanceof Ji ? Tt(Dt(t), { position: e, radius: i, mass: i ** Io * Fo, velocity: C.origin, factor: C.origin }) : s instanceof Ki && Et(t, Pt(e, i)) } class Bo { constructor() { this.distance = 200 } load(t) { t && void 0 !== t.distance && (this.distance = t.distance) } } const qo = "bounce"; class Ho extends xs { constructor(t) { super(t) } clear() { } init() { const t = this.container, e = t.actualOptions.interactivity.modes.bounce; e && (t.retina.bounceModeDistance = e.distance * t.retina.pixelRatio) } interact() { const t = this.container, e = t.actualOptions.interactivity.events, i = t.interactivity.status === r, s = e.onHover.enable, o = e.onHover.mode, n = e.onDiv; i && s && gt(qo, o) ? function (t, e) { const i = 10 * t.retina.pixelRatio, s = t.interactivity.mouse.position, o = t.retina.bounceModeDistance; !o || o < 0 || !s || Lo(t, s, o, new Ji(s.x, s.y, o + i), e) }(this.container, (t => this.isEnabled(t))) : function (t, e, i, s) { Mt(i, e, ((e, i) => function (t, e, i, s) { const o = document.querySelectorAll(e); o.length && o.forEach((e => { const o = e, n = t.retina.pixelRatio, a = { x: (o.offsetLeft + o.offsetWidth * Ao) * n, y: (o.offsetTop + o.offsetHeight * Ao) * n }, r = o.offsetWidth * Ao * n, c = 10 * n, l = i.type === Ee.circle ? new Ji(a.x, a.y, r + c) : new Ki(o.offsetLeft * n - c, o.offsetTop * n - c, o.offsetWidth * n + 2 * c, o.offsetHeight * n + 2 * c); s(a, r, l) })) }(t, e, i, ((e, i, o) => Lo(t, e, i, o, s))))) }(this.container, n, qo, (t => this.isEnabled(t))) } isEnabled(t) { const e = this.container, i = e.actualOptions, s = e.interactivity.mouse, o = (t?.interactivity ?? i.interactivity).events, n = o.onDiv; return !!s.position && o.onHover.enable && gt(qo, o.onHover.mode) || Ct(qo, n) } loadModeOptions(t, ...e) { t.bounce || (t.bounce = new Bo); for (const i of e) t.bounce.load(i?.bounce) } reset() { } } class Uo { constructor() { this.distance = 200, this.duration = .4, this.mix = !1 } load(t) { if (t) { if (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.mix && (this.mix = t.mix), void 0 !== t.opacity && (this.opacity = t.opacity), void 0 !== t.color) { const e = P(this.color) ? void 0 : this.color; this.color = Rt(t.color, (t => Ve.create(e, t))) } void 0 !== t.size && (this.size = t.size) } } } class Vo extends Uo { constructor() { super(), this.selectors = [] } load(t) { super.load(t), t && void 0 !== t.selectors && (this.selectors = t.selectors) } } class Wo extends Uo { load(t) { super.load(t), t && (this.divs = Rt(t.divs, (t => { const e = new Vo; return e.load(t), e }))) } } var jo; function $o(t, e, i, s) { return e >= i ? B(t + (e - i) * s, t, e) : e < i ? B(t - (i - e) * s, e, t) : void 0 } !function (t) { t.color = "color", t.opacity = "opacity", t.size = "size" }(jo || (jo = {})); const Go = "bubble"; class No extends xs { constructor(t) { super(t), this._clickBubble = () => { const t = this.container, e = t.actualOptions, i = t.interactivity.mouse.clickPosition, s = e.interactivity.modes.bubble; if (!s || !i) return; t.bubble || (t.bubble = {}); const o = t.retina.bubbleModeDistance; if (!o || o < 0) return; const n = t.particles.quadTree.queryCircle(i, o, (t => this.isEnabled(t))), { bubble: a } = t; for (const e of n) { if (!a.clicking) continue; e.bubble.inRange = !a.durationEnd; const n = G(e.getPosition(), i), r = ((new Date).getTime() - (t.interactivity.mouse.clickTime ?? 0)) / y; r > s.duration && (a.durationEnd = !0), r > 2 * s.duration && (a.clicking = !1, a.durationEnd = !1); const c = { bubbleObj: { optValue: t.retina.bubbleModeSize, value: e.bubble.radius }, particlesObj: { optValue: W(e.options.size.value) * t.retina.pixelRatio, value: e.size.value }, type: jo.size }; this._process(e, n, r, c); const l = { bubbleObj: { optValue: s.opacity, value: e.bubble.opacity }, particlesObj: { optValue: W(e.options.opacity.value), value: e.opacity?.value ?? 1 }, type: jo.opacity }; this._process(e, n, r, l), !a.durationEnd && n <= o ? this._hoverBubbleColor(e, n) : delete e.bubble.color } }, this._hoverBubble = () => { const t = this.container, e = t.interactivity.mouse.position, i = t.retina.bubbleModeDistance; if (!i || i < 0 || !e) return; const s = t.particles.quadTree.queryCircle(e, i, (t => this.isEnabled(t))); for (const o of s) { o.bubble.inRange = !0; const s = G(o.getPosition(), e), a = 1 - s / i; s <= i ? a >= 0 && t.interactivity.status === r && (this._hoverBubbleSize(o, a), this._hoverBubbleOpacity(o, a), this._hoverBubbleColor(o, a)) : this.reset(o), t.interactivity.status === n && this.reset(o) } }, this._hoverBubbleColor = (t, e, i) => { const s = this.container.actualOptions, o = i ?? s.interactivity.modes.bubble; if (o) { if (!t.bubble.finalColor) { const e = o.color; if (!e) return; const i = It(e); t.bubble.finalColor = Yt(i) } if (t.bubble.finalColor) if (o.mix) { t.bubble.color = void 0; const i = t.getFillColor(); t.bubble.color = i ? Jt(ae(i, t.bubble.finalColor, 1 - e, e)) : t.bubble.finalColor } else t.bubble.color = t.bubble.finalColor } }, this._hoverBubbleOpacity = (t, e, i) => { const s = this.container.actualOptions, o = i?.opacity ?? s.interactivity.modes.bubble?.opacity; if (!o) return; const n = t.options.opacity.value, a = $o(t.opacity?.value ?? 1, o, W(n), e); void 0 !== a && (t.bubble.opacity = a) }, this._hoverBubbleSize = (t, e, i) => { const s = this.container, o = i?.size ? i.size * s.retina.pixelRatio : s.retina.bubbleModeSize; if (void 0 === o) return; const n = W(t.options.size.value) * s.retina.pixelRatio, a = $o(t.size.value, o, n, e); void 0 !== a && (t.bubble.radius = a) }, this._process = (t, e, i, s) => { const o = this.container, n = s.bubbleObj.optValue, a = o.actualOptions.interactivity.modes.bubble; if (!a || void 0 === n) return; const r = a.duration, c = o.retina.bubbleModeDistance, l = s.particlesObj.optValue, h = s.bubbleObj.value, d = s.particlesObj.value ?? 0, u = s.type; if (c && !(c < 0) && n !== l) if (o.bubble || (o.bubble = {}), o.bubble.durationEnd) h && (u === jo.size && delete t.bubble.radius, u === jo.opacity && delete t.bubble.opacity); else if (e <= c) { if ((h ?? d) !== n) { const e = d - i * (d - n) / r; u === jo.size && (t.bubble.radius = e), u === jo.opacity && (t.bubble.opacity = e) } } else u === jo.size && delete t.bubble.radius, u === jo.opacity && delete t.bubble.opacity }, this._singleSelectorHover = (t, e, i) => { const s = this.container, o = document.querySelectorAll(e), n = s.actualOptions.interactivity.modes.bubble; n && o.length && o.forEach((e => { const o = e, a = s.retina.pixelRatio, r = { x: (o.offsetLeft + .5 * o.offsetWidth) * a, y: (o.offsetTop + .5 * o.offsetHeight) * a }, c = .5 * o.offsetWidth * a, l = i.type === Ee.circle ? new Ji(r.x, r.y, c) : new Ki(o.offsetLeft * a, o.offsetTop * a, o.offsetWidth * a, o.offsetHeight * a), h = s.particles.quadTree.query(l, (t => this.isEnabled(t))); for (const e of h) { if (!l.contains(e.getPosition())) continue; e.bubble.inRange = !0; const i = St(n.divs, o); e.bubble.div && e.bubble.div === o || (this.clear(e, t, !0), e.bubble.div = o), this._hoverBubbleSize(e, 1, i), this._hoverBubbleOpacity(e, 1, i), this._hoverBubbleColor(e, 1, i) } })) }, t.bubble || (t.bubble = {}), this.handleClickMode = e => { e === Go && (t.bubble || (t.bubble = {}), t.bubble.clicking = !0) } } clear(t, e, i) { t.bubble.inRange && !i || (delete t.bubble.div, delete t.bubble.opacity, delete t.bubble.radius, delete t.bubble.color) } init() { const t = this.container, e = t.actualOptions.interactivity.modes.bubble; e && (t.retina.bubbleModeDistance = e.distance * t.retina.pixelRatio, void 0 !== e.size && (t.retina.bubbleModeSize = e.size * t.retina.pixelRatio)) } interact(t) { const e = this.container.actualOptions.interactivity.events, i = e.onHover, s = e.onClick, o = i.enable, n = i.mode, a = s.enable, r = s.mode, c = e.onDiv; o && gt(Go, n) ? this._hoverBubble() : a && gt(Go, r) ? this._clickBubble() : Mt(Go, c, ((e, i) => this._singleSelectorHover(t, e, i))) } isEnabled(t) { const e = this.container, i = e.actualOptions, s = e.interactivity.mouse, o = (t?.interactivity ?? i.interactivity).events, { onClick: n, onDiv: a, onHover: r } = o, c = Ct(Go, a); return !!(c || r.enable && s.position || n.enable && s.clickPosition) && (gt(Go, r.mode) || gt(Go, n.mode) || c) } loadModeOptions(t, ...e) { t.bubble || (t.bubble = new Wo); for (const i of e) t.bubble.load(i?.bubble) } reset(t) { t.bubble.inRange = !1 } } class Qo { constructor() { this.opacity = .5 } load(t) { t && void 0 !== t.opacity && (this.opacity = t.opacity) } } class Zo { constructor() { this.distance = 80, this.links = new Qo, this.radius = 60 } load(t) { t && (void 0 !== t.distance && (this.distance = t.distance), this.links.load(t.links), void 0 !== t.radius && (this.radius = t.radius)) } } const Xo = 0, Yo = 1; function Jo(t, e, i) { t.canvas.draw((s => { const o = function (t, e, i, s) { const o = t.actualOptions.interactivity.modes.connect; if (o) return function (t, e, i, s) { const o = Math.floor(i.getRadius() / e.getRadius()), n = e.getFillColor(), a = i.getFillColor(); if (!n || !a) return; const r = e.getPosition(), c = i.getPosition(), l = ae(n, a, e.getRadius(), i.getRadius()), h = t.createLinearGradient(r.x, r.y, c.x, c.y); return h.addColorStop(Xo, ne(n, s)), h.addColorStop(B(o, Xo, Yo), oe(l, s)), h.addColorStop(Yo, ne(a, s)), h }(e, i, s, o.links.opacity) }(t, s, e, i); if (!o) return; const n = e.getPosition(), a = i.getPosition(); !function (t, e, i, s, o) { ve(t, s, o), t.lineWidth = e, t.strokeStyle = i, t.stroke() }(s, e.retina.linksWidth ?? 0, o, n, a) })) } class Ko extends xs { constructor(t) { super(t) } clear() { } init() { const t = this.container, e = t.actualOptions.interactivity.modes.connect; e && (t.retina.connectModeDistance = e.distance * t.retina.pixelRatio, t.retina.connectModeRadius = e.radius * t.retina.pixelRatio) } interact() { const t = this.container; if (t.actualOptions.interactivity.events.onHover.enable && "pointermove" === t.interactivity.status) { const e = t.interactivity.mouse.position, { connectModeDistance: i, connectModeRadius: s } = t.retina; if (!i || i < 0 || !s || s < 0 || !e) return; const o = Math.abs(s), n = t.particles.quadTree.queryCircle(e, o, (t => this.isEnabled(t))); n.forEach(((e, s) => { const o = e.getPosition(); for (const a of n.slice(s + 1)) { const s = a.getPosition(), n = Math.abs(i), r = Math.abs(o.x - s.x), c = Math.abs(o.y - s.y); r < n && c < n && Jo(t, e, a) } })) } } isEnabled(t) { const e = this.container, i = e.interactivity.mouse, s = (t?.interactivity ?? e.actualOptions.interactivity).events; return !(!s.onHover.enable || !i.position) && gt("connect", s.onHover.mode) } loadModeOptions(t, ...e) { t.connect || (t.connect = new Zo); for (const i of e) t.connect.load(i?.connect) } reset() { } } class tn { constructor() { this.blink = !1, this.consent = !1, this.opacity = 1 } load(t) { t && (void 0 !== t.blink && (this.blink = t.blink), void 0 !== t.color && (this.color = Ve.create(this.color, t.color)), void 0 !== t.consent && (this.consent = t.consent), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class en { constructor() { this.distance = 100, this.links = new tn } load(t) { t && (void 0 !== t.distance && (this.distance = t.distance), this.links.load(t.links)) } } function sn(t, e, i, s, o) { t.canvas.draw((t => { const n = e.getPosition(); !function (t, e, i, s, o, n) { ve(t, i, s), t.strokeStyle = oe(o, n), t.lineWidth = e, t.stroke() }(t, e.retina.linksWidth ?? 0, n, o, i, s) })) } class on extends xs { constructor(t) { super(t) } clear() { } init() { const t = this.container, e = t.actualOptions.interactivity.modes.grab; e && (t.retina.grabModeDistance = e.distance * t.retina.pixelRatio) } interact() { const t = this.container, e = t.actualOptions.interactivity; if (!e.modes.grab || !e.events.onHover.enable || t.interactivity.status !== r) return; const i = t.interactivity.mouse.position; if (!i) return; const s = t.retina.grabModeDistance; if (!s || s < 0) return; const o = t.particles.quadTree.queryCircle(i, s, (t => this.isEnabled(t))); for (const n of o) { const o = G(n.getPosition(), i); if (o > s) continue; const a = e.modes.grab.links, r = a.opacity, c = r - o * r / s; if (c <= 0) continue; const l = a.color ?? n.options.links?.color; if (!t.particles.grabLineColor && l) { const i = e.modes.grab.links; t.particles.grabLineColor = ce(l, i.blink, i.consent) } const h = re(n, void 0, t.particles.grabLineColor); h && sn(t, n, h, c, i) } } isEnabled(t) { const e = this.container, i = e.interactivity.mouse, s = (t?.interactivity ?? e.actualOptions.interactivity).events; return s.onHover.enable && !!i.position && gt("grab", s.onHover.mode) } loadModeOptions(t, ...e) { t.grab || (t.grab = new en); for (const i of e) t.grab.load(i?.grab) } reset() { } } class nn extends xs { constructor(t) { super(t), this.handleClickMode = t => { if ("pause" !== t) return; const e = this.container; e.animationStatus ? e.pause() : e.play() } } clear() { } init() { } interact() { } isEnabled() { return !0 } reset() { } } class an { constructor() { this.default = !0, this.groups = [], this.quantity = 4 } load(t) { if (!t) return; void 0 !== t.default && (this.default = t.default), void 0 !== t.groups && (this.groups = t.groups.map((t => t))), this.groups.length || (this.default = !0); const e = t.quantity; void 0 !== e && (this.quantity = j(e)) } } class rn extends xs { constructor(t) { super(t), this.handleClickMode = t => { if ("push" !== t) return; const e = this.container, i = e.actualOptions.interactivity.modes.push; if (!i) return; const s = U(i.quantity); if (s <= 0) return; const o = xt([void 0, ...i.groups]), n = void 0 !== o ? e.actualOptions.particles.groups[o] : void 0; e.particles.push(s, e.interactivity.mouse, n, o) } } clear() { } init() { } interact() { } isEnabled() { return !0 } loadModeOptions(t, ...e) { t.push || (t.push = new an); for (const i of e) t.push.load(i?.push) } reset() { } } class cn { constructor() { this.quantity = 2 } load(t) { if (!t) return; const e = t.quantity; void 0 !== e && (this.quantity = j(e)) } } class ln extends xs { constructor(t) { super(t), this.handleClickMode = t => { const e = this.container, i = e.actualOptions; if (!i.interactivity.modes.remove || "remove" !== t) return; const s = U(i.interactivity.modes.remove.quantity); e.particles.removeQuantity(s) } } clear() { } init() { } interact() { } isEnabled() { return !0 } loadModeOptions(t, ...e) { t.remove || (t.remove = new cn); for (const i of e) t.remove.load(i?.remove) } reset() { } } class hn { constructor() { this.distance = 200, this.duration = .4, this.factor = 100, this.speed = 1, this.maxSpeed = 50, this.easing = gs.easeOutQuad } load(t) { t && (void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.duration && (this.duration = t.duration), void 0 !== t.easing && (this.easing = t.easing), void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.speed && (this.speed = t.speed), void 0 !== t.maxSpeed && (this.maxSpeed = t.maxSpeed)) } } class dn extends hn { constructor() { super(), this.selectors = [] } load(t) { super.load(t), t && void 0 !== t.selectors && (this.selectors = t.selectors) } } class un extends hn { load(t) { super.load(t), t && (this.divs = Rt(t.divs, (t => { const e = new dn; return e.load(t), e }))) } } const pn = "repulse"; class fn extends xs { constructor(t, e) { super(e), this._clickRepulse = () => { const t = this.container, e = t.actualOptions.interactivity.modes.repulse; if (!e) return; const i = t.repulse ?? { particles: [] }; if (i.finish || (i.count || (i.count = 0), i.count++, i.count === t.particles.count && (i.finish = !0)), i.clicking) { const s = t.retina.repulseModeDistance; if (!s || s < 0) return; const o = Math.pow(s / 6, 3), n = t.interactivity.mouse.clickPosition; if (void 0 === n) return; const a = new Ji(n.x, n.y, o), r = t.particles.quadTree.query(a, (t => this.isEnabled(t))); for (const t of r) { const { dx: s, dy: a, distance: r } = $(n, t.position), c = r ** 2, l = -o * e.speed / c; if (c <= o) { i.particles.push(t); const e = C.create(s, a); e.length = l, t.velocity.setTo(e) } } } else if (!1 === i.clicking) { for (const t of i.particles) t.velocity.setTo(t.initialVelocity); i.particles = [] } }, this._hoverRepulse = () => { const t = this.container, e = t.interactivity.mouse.position, i = t.retina.repulseModeDistance; !i || i < 0 || !e || this._processRepulse(e, i, new Ji(e.x, e.y, i)) }, this._processRepulse = (t, e, i, s) => { const o = this.container, n = o.particles.quadTree.query(i, (t => this.isEnabled(t))), a = o.actualOptions.interactivity.modes.repulse; if (!a) return; const { easing: r, speed: c, factor: l, maxSpeed: h } = a, d = E(r), u = (s?.speed ?? c) * l; for (const i of n) { const { dx: s, dy: o, distance: n } = $(i.position, t), a = B(d(1 - n / e) * u, 0, h), r = C.create(n ? s / n * a : u, n ? o / n * a : u); i.position.addTo(r) } }, this._singleSelectorRepulse = (t, e) => { const i = this.container, s = i.actualOptions.interactivity.modes.repulse; if (!s) return; const o = document.querySelectorAll(t); o.length && o.forEach((t => { const o = t, n = i.retina.pixelRatio, a = { x: (o.offsetLeft + .5 * o.offsetWidth) * n, y: (o.offsetTop + .5 * o.offsetHeight) * n }, r = .5 * o.offsetWidth * n, c = e.type === Ee.circle ? new Ji(a.x, a.y, r) : new Ki(o.offsetLeft * n, o.offsetTop * n, o.offsetWidth * n, o.offsetHeight * n), l = St(s.divs, o); this._processRepulse(a, r, c, l) })) }, this._engine = t, e.repulse || (e.repulse = { particles: [] }), this.handleClickMode = t => { const i = this.container.actualOptions.interactivity.modes.repulse; if (!i || t !== pn) return; e.repulse || (e.repulse = { particles: [] }); const s = e.repulse; s.clicking = !0, s.count = 0; for (const t of e.repulse.particles) this.isEnabled(t) && t.velocity.setTo(t.initialVelocity); s.particles = [], s.finish = !1, setTimeout((() => { e.destroyed || (s.clicking = !1) }), i.duration * y) } } clear() { } init() { const t = this.container, e = t.actualOptions.interactivity.modes.repulse; e && (t.retina.repulseModeDistance = e.distance * t.retina.pixelRatio) } interact() { const t = this.container, e = t.actualOptions, i = t.interactivity.status === r, s = e.interactivity.events, o = s.onHover, n = o.enable, a = o.mode, c = s.onClick, l = c.enable, h = c.mode, d = s.onDiv; i && n && gt(pn, a) ? this._hoverRepulse() : l && gt(pn, h) ? this._clickRepulse() : Mt(pn, d, ((t, e) => this._singleSelectorRepulse(t, e))) } isEnabled(t) { const e = this.container, i = e.actualOptions, s = e.interactivity.mouse, o = (t?.interactivity ?? i.interactivity).events, n = o.onDiv, a = o.onHover, r = o.onClick, c = Ct(pn, n); if (!(c || a.enable && s.position || r.enable && s.clickPosition)) return !1; const l = a.mode, h = r.mode; return gt(pn, l) || gt(pn, h) || c } loadModeOptions(t, ...e) { t.repulse || (t.repulse = new un); for (const i of e) t.repulse.load(i?.repulse) } reset() { } } class mn { constructor() { this.factor = 3, this.radius = 200 } load(t) { t && (void 0 !== t.factor && (this.factor = t.factor), void 0 !== t.radius && (this.radius = t.radius)) } } class vn extends xs { constructor(t) { super(t) } clear(t, e, i) { t.slow.inRange && !i || (t.slow.factor = 1) } init() { const t = this.container, e = t.actualOptions.interactivity.modes.slow; e && (t.retina.slowModeRadius = e.radius * t.retina.pixelRatio) } interact() { } isEnabled(t) { const e = this.container, i = e.interactivity.mouse, s = (t?.interactivity ?? e.actualOptions.interactivity).events; return s.onHover.enable && !!i.position && gt("slow", s.onHover.mode) } loadModeOptions(t, ...e) { t.slow || (t.slow = new mn); for (const i of e) t.slow.load(i?.slow) } reset(t) { t.slow.inRange = !1; const e = this.container, i = e.actualOptions, s = e.interactivity.mouse.position, o = e.retina.slowModeRadius, n = i.interactivity.modes.slow; if (!n || !o || o < 0 || !s) return; const a = G(s, t.getPosition()), r = a / o, c = n.factor, { slow: l } = t; a > o || (l.inRange = !0, l.factor = r / c) } } const yn = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d.]+%?\))|currentcolor/gi; async function gn(t) { return new Promise((e => { t.loading = !0; const i = new Image; t.element = i, i.addEventListener("load", (() => { t.loading = !1, e() })), i.addEventListener("error", (() => { t.element = void 0, t.error = !0, t.loading = !1, dt().error(`${f} loading image: ${t.source}`), e() })), i.src = t.source })) } async function bn(t) { if ("svg" !== t.type) return void await gn(t); t.loading = !0; const e = await fetch(t.source); e.ok ? t.svgData = await e.text() : (dt().error(`${f} Image not found`), t.error = !0), t.loading = !1 } const wn = [0, 4, 2, 1], xn = [8, 8, 4, 2]; class _n { constructor(t) { this.pos = 0, this.data = new Uint8ClampedArray(t) } getString(t) { const e = this.data.slice(this.pos, this.pos + t); return this.pos += e.length, e.reduce(((t, e) => t + String.fromCharCode(e)), "") } nextByte() { return this.data[this.pos++] } nextTwoBytes() { return this.pos += 2, this.data[this.pos - 2] + (this.data[this.pos - 1] << 8) } readSubBlocks() { let t = "", e = 0; do { e = this.data[this.pos++]; for (let i = e; --i >= 0; t += String.fromCharCode(this.data[this.pos++])); } while (0 !== e); return t } readSubBlocksBin() { let t = this.data[this.pos], e = 0; for (let i = 0; 0 !== t; i += t + 1, t = this.data[this.pos + i])e += t; const i = new Uint8Array(e); t = this.data[this.pos++]; for (let e = 0; 0 !== t; t = this.data[this.pos++])for (let s = t; --s >= 0; i[e++] = this.data[this.pos++]); return i } skipSubBlocks() { for (const t = 1, e = 0; this.data[this.pos] !== e; this.pos += this.data[this.pos] + t); this.pos++ } } var kn, Pn; !function (t) { t[t.Replace = 0] = "Replace", t[t.Combine = 1] = "Combine", t[t.RestoreBackground = 2] = "RestoreBackground", t[t.RestorePrevious = 3] = "RestorePrevious", t[t.UndefinedA = 4] = "UndefinedA", t[t.UndefinedB = 5] = "UndefinedB", t[t.UndefinedC = 6] = "UndefinedC", t[t.UndefinedD = 7] = "UndefinedD" }(kn || (kn = {})), function (t) { t[t.Extension = 33] = "Extension", t[t.ApplicationExtension = 255] = "ApplicationExtension", t[t.GraphicsControlExtension = 249] = "GraphicsControlExtension", t[t.PlainTextExtension = 1] = "PlainTextExtension", t[t.CommentExtension = 254] = "CommentExtension", t[t.Image = 44] = "Image", t[t.EndOfFile = 59] = "EndOfFile" }(Pn || (Pn = {})); const zn = 0; function Cn(t, e) { const i = []; for (let s = 0; s < e; s++)i.push({ r: t.data[t.pos], g: t.data[t.pos + 1], b: t.data[t.pos + 2] }), t.pos += 3; return i } async function Mn(t, e, i, s, o, n) { switch (t.nextByte()) { case Pn.EndOfFile: return !0; case Pn.Image: await async function (t, e, i, s, o, n) { const a = e.frames[s(!0)]; a.left = t.nextTwoBytes(), a.top = t.nextTwoBytes(), a.width = t.nextTwoBytes(), a.height = t.nextTwoBytes(); const r = t.nextByte(), c = 128 == (128 & r), l = 64 == (64 & r); a.sortFlag = 32 == (32 & r), a.reserved = (24 & r) >>> 3; const h = 1 << 1 + (7 & r); c && (a.localColorTable = Cn(t, h)); const d = t => { const { r: s, g: n, b: r } = (c ? a.localColorTable : e.globalColorTable)[t]; return t !== o(null) ? { r: s, g: n, b: r, a: 255 } : { r: s, g: n, b: r, a: i ? ~~((s + n + r) / 3) : 0 } }, u = (() => { try { return new ImageData(a.width, a.height, { colorSpace: "srgb" }) } catch (t) { if (t instanceof DOMException && "IndexSizeError" === t.name) return null; throw t } })(); if (null == u) throw new EvalError("GIF frame size is to large"); const p = t.nextByte(), f = t.readSubBlocksBin(), m = 1 << p, v = (t, e) => { const i = t >>> 3, s = 7 & t; return (f[i] + (f[i + 1] << 8) + (f[i + 2] << 16) & (1 << e) - 1 << s) >>> s }; if (l) { for (let i = 0, o = p + 1, r = 0, c = [[0]], l = 0; l < 4; l++) { if (wn[l] < a.height) { let t = 0, e = 0, s = !1; for (; !s;) { const n = i; if (i = v(r, o), r += o + 1, i === m) { o = p + 1, c.length = m + 2; for (let t = 0; t < c.length; t++)c[t] = t < m ? [t] : [] } else { i >= c.length ? c.push(c[n].concat(c[n][0])) : n !== m && c.push(c[n].concat(c[i][0])); for (const s of c[i]) { const { r: i, g: o, b: n, a: r } = d(s); u.data.set([i, o, n, r], wn[l] * a.width + xn[l] * e + t % (4 * a.width)), t += 4 } c.length === 1 << o && o < 12 && o++ } t === 4 * a.width * (e + 1) && (e++, wn[l] + xn[l] * e >= a.height && (s = !0)) } } n?.(t.pos / (t.data.length - 1), s(!1) + 1, u, { x: a.left, y: a.top }, { width: e.width, height: e.height }) } a.image = u, a.bitmap = await createImageBitmap(u) } else { let i = 0, o = p + 1, r = 0, c = -4, l = !1; const h = [[0]]; for (; !l;) { const t = i; if (i = v(r, o), r += o, i === m) { o = p + 1, h.length = m + 2; for (let t = 0; t < h.length; t++)h[t] = t < m ? [t] : [] } else { if (i === m + 1) { l = !0; break } i >= h.length ? h.push(h[t].concat(h[t][0])) : t !== m && h.push(h[t].concat(h[i][0])); for (const t of h[i]) { const { r: e, g: i, b: s, a: o } = d(t); u.data.set([e, i, s, o], c += 4) } h.length >= 1 << o && o < 12 && o++ } } a.image = u, a.bitmap = await createImageBitmap(u), n?.((t.pos + 1) / t.data.length, s(!1) + 1, a.image, { x: a.left, y: a.top }, { width: e.width, height: e.height }) } }(t, e, i, s, o, n); break; case Pn.Extension: !function (t, e, i, s) { switch (t.nextByte()) { case Pn.GraphicsControlExtension: { const o = e.frames[i(!1)]; t.pos++; const n = t.nextByte(); o.GCreserved = (224 & n) >>> 5, o.disposalMethod = (28 & n) >>> 2, o.userInputDelayFlag = 2 == (2 & n); const a = 1 == (1 & n); o.delayTime = 10 * t.nextTwoBytes(); const r = t.nextByte(); a && s(r), t.pos++; break } case Pn.ApplicationExtension: { t.pos++; const i = { identifier: t.getString(8), authenticationCode: t.getString(3), data: t.readSubBlocksBin() }; e.applicationExtensions.push(i); break } case Pn.CommentExtension: e.comments.push([i(!1), t.readSubBlocks()]); break; case Pn.PlainTextExtension: if (0 === e.globalColorTable.length) throw new EvalError("plain text extension without global color table"); t.pos++, e.frames[i(!1)].plainTextData = { left: t.nextTwoBytes(), top: t.nextTwoBytes(), width: t.nextTwoBytes(), height: t.nextTwoBytes(), charSize: { width: t.nextTwoBytes(), height: t.nextTwoBytes() }, foregroundColor: t.nextByte(), backgroundColor: t.nextByte(), text: t.readSubBlocks() }; break; default: t.skipSubBlocks() } }(t, e, s, o); break; default: throw new EvalError("undefined block found") }return !1 } async function On(t) { if ("gif" === t.type) { t.loading = !0; try { t.gifData = await async function (t, e, i) { i || (i = !1); const s = await fetch(t); if (!s.ok && 404 === s.status) throw new EvalError("file not found"); const o = await s.arrayBuffer(), n = { width: 0, height: 0, totalTime: 0, colorRes: 0, pixelAspectRatio: 0, frames: [], sortFlag: !1, globalColorTable: [], backgroundImage: new ImageData(1, 1, { colorSpace: "srgb" }), comments: [], applicationExtensions: [] }, a = new _n(new Uint8ClampedArray(o)); if ("GIF89a" !== a.getString(6)) throw new Error("not a supported GIF file"); n.width = a.nextTwoBytes(), n.height = a.nextTwoBytes(); const r = a.nextByte(), c = 128 == (128 & r); n.colorRes = (112 & r) >>> 4, n.sortFlag = 8 == (8 & r); const l = 1 << 1 + (7 & r), h = a.nextByte(); n.pixelAspectRatio = a.nextByte(), 0 !== n.pixelAspectRatio && (n.pixelAspectRatio = (n.pixelAspectRatio + 15) / 64), c && (n.globalColorTable = Cn(a, l)); const d = (() => { try { return new ImageData(n.width, n.height, { colorSpace: "srgb" }) } catch (t) { if (t instanceof DOMException && "IndexSizeError" === t.name) return null; throw t } })(); if (null == d) throw new Error("GIF frame size is to large"); const { r: u, g: p, b: f } = n.globalColorTable[h]; d.data.set(c ? [u, p, f, 255] : [0, 0, 0, 0]); for (let t = 4; t < d.data.length; t *= 2)d.data.copyWithin(t, 0, t); n.backgroundImage = d; let m = -1, v = !0, y = -1; const g = t => (t && (v = !0), m), b = t => (null != t && (y = t), y); try { do { v && (n.frames.push({ left: 0, top: 0, width: 0, height: 0, disposalMethod: kn.Replace, image: new ImageData(1, 1, { colorSpace: "srgb" }), plainTextData: null, userInputDelayFlag: !1, delayTime: 0, sortFlag: !1, localColorTable: [], reserved: 0, GCreserved: 0 }), m++, y = -1, v = !1) } while (!await Mn(a, n, i, g, b, undefined)); n.frames.length--; for (const t of n.frames) { if (t.userInputDelayFlag && 0 === t.delayTime) { n.totalTime = 1 / 0; break } n.totalTime += t.delayTime } return n } catch (t) { if (t instanceof EvalError) throw new Error(`error while parsing frame ${m} "${t.message}"`); throw t } }(t.source), t.gifLoopCount = function (t) { for (const e of t.applicationExtensions) if (e.identifier + e.authenticationCode === "NETSCAPE2.0") return e.data[1] + (e.data[2] << 8); return NaN }(t.gifData) ?? zn, t.gifLoopCount || (t.gifLoopCount = 1 / 0) } catch { t.error = !0 } t.loading = !1 } else await gn(t) } class Sn { constructor(t) { this.validTypes = ["image", "images"], this.loadImageShape = async t => { if (!this._engine.loadImage) throw new Error(`${f} image shape not initialized`); await this._engine.loadImage({ gif: t.gif, name: t.name, replaceColor: t.replaceColor ?? !1, src: t.src }) }, this._engine = t } addImage(t) { this._engine.images || (this._engine.images = []), this._engine.images.push(t) } draw(t) { const { context: e, radius: i, particle: s, opacity: o } = t, n = s.image, a = n?.element; if (n) { if (e.globalAlpha = o, n.gif && n.gifData) !function (t) { const { context: e, radius: i, particle: s, delta: o } = t, n = s.image; if (!n?.gifData || !n.gif) return; const a = new OffscreenCanvas(n.gifData.width, n.gifData.height), r = a.getContext("2d"); if (!r) throw new Error("could not create offscreen canvas context"); r.imageSmoothingQuality = "low", r.imageSmoothingEnabled = !1, r.clearRect(0, 0, a.width, a.height), void 0 === s.gifLoopCount && (s.gifLoopCount = n.gifLoopCount ?? zn); let c = s.gifFrame ?? 0; const l = { x: .5 * -n.gifData.width, y: .5 * -n.gifData.height }, h = n.gifData.frames[c]; if (void 0 === s.gifTime && (s.gifTime = 0), h.bitmap) { switch (e.scale(i / n.gifData.width, i / n.gifData.height), h.disposalMethod) { case kn.UndefinedA: case kn.UndefinedB: case kn.UndefinedC: case kn.UndefinedD: case kn.Replace: r.drawImage(h.bitmap, h.left, h.top), e.drawImage(a, l.x, l.y), r.clearRect(0, 0, a.width, a.height); break; case kn.Combine: r.drawImage(h.bitmap, h.left, h.top), e.drawImage(a, l.x, l.y); break; case kn.RestoreBackground: r.drawImage(h.bitmap, h.left, h.top), e.drawImage(a, l.x, l.y), r.clearRect(0, 0, a.width, a.height), n.gifData.globalColorTable.length ? r.putImageData(n.gifData.backgroundImage, l.x, l.y) : r.putImageData(n.gifData.frames[0].image, l.x + h.left, l.y + h.top); break; case kn.RestorePrevious: { const t = r.getImageData(0, 0, a.width, a.height); r.drawImage(h.bitmap, h.left, h.top), e.drawImage(a, l.x, l.y), r.clearRect(0, 0, a.width, a.height), r.putImageData(t, 0, 0) } }if (s.gifTime += o.value, s.gifTime > h.delayTime) { if (s.gifTime -= h.delayTime, ++c >= n.gifData.frames.length) { if (--s.gifLoopCount <= zn) return; c = 0, r.clearRect(0, 0, a.width, a.height) } s.gifFrame = c } e.scale(n.gifData.width / i, n.gifData.height / i) } }(t); else if (a) { const t = n.ratio, s = { x: -i, y: -i }, o = 2 * i; e.drawImage(a, s.x, s.y, o, o / t) } e.globalAlpha = 1 } } getSidesCount() { return 12 } async init(t) { const e = t.actualOptions; if (e.preload && this._engine.loadImage) for (const t of e.preload) await this._engine.loadImage(t) } loadShape(t) { if ("image" !== t.shape && "images" !== t.shape) return; this._engine.images || (this._engine.images = []); const e = t.shapeData; e && (this._engine.images.find((t => t.name === e.name || t.source === e.src)) || this.loadImageShape(e).then((() => { this.loadShape(t) }))) } particleInit(t, e) { if ("image" !== e.shape && "images" !== e.shape) return; this._engine.images || (this._engine.images = []); const i = this._engine.images, s = e.shapeData; if (!s) return; const o = e.getFillColor(), n = i.find((t => t.name === s.name || t.source === s.src)); if (!n) return; const a = s.replaceColor ?? n.replaceColor; n.loading ? setTimeout((() => { this.particleInit(t, e) })) : (async () => { let t; t = n.svgData && o ? await function (t, e, i, s) { const o = function (t, e, i) { const { svgData: s } = t; if (!s) return ""; const o = ne(e, i); if (s.includes("fill")) return s.replace(yn, (() => o)); const n = s.indexOf(">"); return `${s.substring(0, n)} fill="${o}"${s.substring(n)}` }(t, i, s.opacity?.value ?? 1), n = { color: i, gif: e.gif, data: { ...t, svgData: o }, loaded: !1, ratio: e.width / e.height, replaceColor: e.replaceColor, source: e.src }; return new Promise((e => { const i = new Blob([o], { type: "image/svg+xml" }), s = URL || window.URL || window.webkitURL || window, a = s.createObjectURL(i), r = new Image; r.addEventListener("load", (() => { n.loaded = !0, n.element = r, e(n), s.revokeObjectURL(a) })), r.addEventListener("error", (() => { (async () => { s.revokeObjectURL(a); const i = { ...t, error: !1, loading: !0 }; await gn(i), n.loaded = !0, n.element = i.element, e(n) })() })), r.src = a })) }(n, s, o, e) : { color: o, data: n, element: n.element, gif: n.gif, gifData: n.gifData, gifLoopCount: n.gifLoopCount, loaded: !0, ratio: s.width && s.height ? s.width / s.height : n.ratio ?? 1, replaceColor: a, source: s.src }, t.ratio || (t.ratio = 1); const i = { image: t, fill: s.fill ?? e.shapeFill, close: s.close ?? e.shapeClose }; e.image = i.image, e.shapeFill = i.fill, e.shapeClose = i.close })() } } class Dn { constructor() { this.src = "", this.gif = !1 } load(t) { t && (void 0 !== t.gif && (this.gif = t.gif), void 0 !== t.height && (this.height = t.height), void 0 !== t.name && (this.name = t.name), void 0 !== t.replaceColor && (this.replaceColor = t.replaceColor), void 0 !== t.src && (this.src = t.src), void 0 !== t.width && (this.width = t.width)) } } class Tn { constructor(t) { this.id = "imagePreloader", this._engine = t } async getPlugin() { return await Promise.resolve(), {} } loadOptions(t, e) { if (!e?.preload) return; t.preload || (t.preload = []); const i = t.preload; for (const t of e.preload) { const e = i.find((e => e.name === t.name || e.src === t.src)); if (e) e.load(t); else { const e = new Dn; e.load(t), i.push(e) } } } needsPlugin() { return !0 } } const En = 3; class Rn extends ui { constructor() { super(), this.sync = !1 } load(t) { t && (super.load(t), void 0 !== t.sync && (this.sync = t.sync)) } } class In extends ui { constructor() { super(), this.sync = !1 } load(t) { t && (super.load(t), void 0 !== t.sync && (this.sync = t.sync)) } } class An { constructor() { this.count = 0, this.delay = new Rn, this.duration = new In } load(t) { t && (void 0 !== t.count && (this.count = t.count), this.delay.load(t.delay), this.duration.load(t.duration)) } } class Fn { constructor(t) { this.container = t } init(t) { const e = this.container, i = t.options.life; i && (t.life = { delay: e.retina.reduceFactor ? U(i.delay.value) * (i.delay.sync ? 1 : I()) / e.retina.reduceFactor * y : 0, delayTime: 0, duration: e.retina.reduceFactor ? U(i.duration.value) * (i.duration.sync ? 1 : I()) / e.retina.reduceFactor * y : 0, time: 0, count: i.count }, t.life.duration <= 0 && (t.life.duration = -1), t.life.count <= 0 && (t.life.count = -1), t.life && (t.spawning = t.life.delay > 0)) } isEnabled(t) { return !t.destroyed } loadOptions(t, ...e) { t.life || (t.life = new An); for (const i of e) t.life.load(i?.life) } update(t, e) { this.isEnabled(t) && t.life && function (t, e, i) { if (!t.life) return; const s = t.life; let o = !1; if (t.spawning) { if (s.delayTime += e.value, !(s.delayTime >= t.life.delay)) return; o = !0, t.spawning = !1, s.delayTime = 0, s.time = 0 } if (-1 === s.duration) return; if (t.spawning) return; if (o ? s.time = 0 : s.time += e.value, s.time < s.duration) return; if (s.time = 0, t.life.count > 0 && t.life.count--, 0 === t.life.count) return void t.destroy(); const n = j(0, i.width), a = j(0, i.width); t.position.x = H(n), t.position.y = H(a), t.spawning = !0, s.delayTime = 0, s.time = 0, t.reset(); const r = t.options.life; r && (s.delay = U(r.delay.value) * y, s.duration = U(r.duration.value) * y) }(t, e, this.container.canvas.size) } } class Ln { constructor() { this.validTypes = ["line"] } draw(t) { !function (t) { const { context: e, particle: i, radius: s } = t, o = i.shapeData; e.moveTo(-s, 0), e.lineTo(s, 0), e.lineCap = o?.cap ?? "butt" }(t) } getSidesCount() { return 1 } } class Bn { init() { } isEnabled(t) { return !pt() && !t.destroyed && t.container.actualOptions.interactivity.events.onHover.parallax.enable } move(t) { const e = t.container, i = e.actualOptions.interactivity.events.onHover.parallax; if (pt() || !i.enable) return; const s = i.force, o = e.interactivity.mouse.position; if (!o) return; const n = e.canvas.size, a = .5 * n.width, r = .5 * n.height, c = i.smooth, l = t.getRadius() / s, h = (o.x - a) * l, d = (o.y - r) * l, { offset: u } = t; u.x += (h - u.x) / c, u.y += (d - u.y) / c } } class qn extends _s { constructor(t) { super(t) } clear() { } init() { } interact(t) { const e = this.container; void 0 === t.attractDistance && (t.attractDistance = U(t.options.move.attract.distance) * e.retina.pixelRatio); const i = t.attractDistance, s = t.getPosition(), o = e.particles.quadTree.queryCircle(s, i); for (const e of o) { if (t === e || !e.options.move.attract.enable || e.destroyed || e.spawning) continue; const i = e.getPosition(), { dx: o, dy: n } = $(s, i), a = t.options.move.attract.rotate, r = o / (1e3 * a.x), c = n / (1e3 * a.y), l = e.size.value / t.size.value, h = 1 / l; t.velocity.x -= r * l, t.velocity.y -= c * l, e.velocity.x += r * h, e.velocity.y += c * h } } isEnabled(t) { return t.options.move.attract.enable } reset() { } } const Hn = .5, Un = 10, Vn = 0; function Wn(t, e, i, s, o, n) { const a = B(t.options.collisions.absorb.speed * o.factor / Un, Vn, s); t.size.value += a * Hn, i.size.value -= a, s <= n && (i.size.value = 0, i.destroy()) } const jn = t => { void 0 === t.collisionMaxSpeed && (t.collisionMaxSpeed = U(t.options.collisions.maxSpeed)), t.velocity.length > t.collisionMaxSpeed && (t.velocity.length = t.collisionMaxSpeed) }; function $n(t, e) { Tt(Dt(t), Dt(e)), jn(t), jn(e) } function Gn(t, e, i, s) { switch (t.options.collisions.mode) { case Ae.absorb: !function (t, e, i, s) { const o = t.getRadius(), n = e.getRadius(); void 0 === o && void 0 !== n ? t.destroy() : void 0 !== o && void 0 === n ? e.destroy() : void 0 !== o && void 0 !== n && (o >= n ? Wn(t, 0, e, n, i, s) : Wn(e, 0, t, o, i, s)) }(t, e, i, s); break; case Ae.bounce: $n(t, e); break; case Ae.destroy: !function (t, e) { t.unbreakable || e.unbreakable || $n(t, e), void 0 === t.getRadius() && void 0 !== e.getRadius() ? t.destroy() : void 0 !== t.getRadius() && void 0 === e.getRadius() ? e.destroy() : void 0 !== t.getRadius() && void 0 !== e.getRadius() && (t.getRadius() >= e.getRadius() ? e : t).destroy() }(t, e) } } class Nn extends _s { constructor(t) { super(t) } clear() { } init() { } interact(t, e) { if (t.destroyed || t.spawning) return; const i = this.container, s = t.getPosition(), o = t.getRadius(), n = i.particles.quadTree.queryCircle(s, 2 * o); for (const a of n) { if (t === a || !a.options.collisions.enable || t.options.collisions.mode !== a.options.collisions.mode || a.destroyed || a.spawning) continue; const n = a.getPosition(), r = a.getRadius(); Math.abs(Math.round(s.z) - Math.round(n.z)) > o + r || (G(s, n) > o + r || Gn(t, a, e, i.retina.pixelRatio)) } } isEnabled(t) { return t.options.collisions.enable } reset() { } } class Qn extends Ji { constructor(t, e, i, s) { super(t, e, i), this.canvasSize = s, this.canvasSize = { ...s } } contains(t) { const { width: e, height: i } = this.canvasSize, { x: s, y: o } = t; return super.contains(t) || super.contains({ x: s - e, y: o }) || super.contains({ x: s - e, y: o - i }) || super.contains({ x: s, y: o - i }) } intersects(t) { if (super.intersects(t)) return !0; const e = t, i = t, s = { x: t.position.x - this.canvasSize.width, y: t.position.y - this.canvasSize.height }; if (void 0 !== i.radius) { const t = new Ji(s.x, s.y, 2 * i.radius); return super.intersects(t) } if (void 0 !== e.size) { const t = new Ki(s.x, s.y, 2 * e.size.width, 2 * e.size.height); return super.intersects(t) } return !1 } } class Zn { constructor() { this.blur = 5, this.color = new Ve, this.color.value = "#000", this.enable = !1 } load(t) { t && (void 0 !== t.blur && (this.blur = t.blur), this.color = Ve.create(this.color, t.color), void 0 !== t.enable && (this.enable = t.enable)) } } class Xn { constructor() { this.enable = !1, this.frequency = 1 } load(t) { t && (void 0 !== t.color && (this.color = Ve.create(this.color, t.color)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.frequency && (this.frequency = t.frequency), void 0 !== t.opacity && (this.opacity = t.opacity)) } } class Yn { constructor() { this.blink = !1, this.color = new Ve, this.color.value = "#fff", this.consent = !1, this.distance = 100, this.enable = !1, this.frequency = 1, this.opacity = 1, this.shadow = new Zn, this.triangles = new Xn, this.width = 1, this.warp = !1 } load(t) { t && (void 0 !== t.id && (this.id = t.id), void 0 !== t.blink && (this.blink = t.blink), this.color = Ve.create(this.color, t.color), void 0 !== t.consent && (this.consent = t.consent), void 0 !== t.distance && (this.distance = t.distance), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.frequency && (this.frequency = t.frequency), void 0 !== t.opacity && (this.opacity = t.opacity), this.shadow.load(t.shadow), this.triangles.load(t.triangles), void 0 !== t.width && (this.width = t.width), void 0 !== t.warp && (this.warp = t.warp)) } } function Jn(t, e, i, s, o) { const { dx: n, dy: a, distance: r } = $(t, e); if (!o || r <= i) return r; const c = { x: Math.abs(n), y: Math.abs(a) }, l = Math.min(c.x, s.width - c.x), h = Math.min(c.y, s.height - c.y); return Math.sqrt(l ** 2 + h ** 2) } class Kn extends _s { constructor(t) { super(t), this._setColor = t => { if (!t.options.links) return; const e = this.linkContainer, i = t.options.links; let s = void 0 === i.id ? e.particles.linksColor : e.particles.linksColors.get(i.id); s || (s = ce(i.color, i.blink, i.consent), void 0 === i.id ? e.particles.linksColor = s : e.particles.linksColors.set(i.id, s)) }, this.linkContainer = t } clear() { } init() { this.linkContainer.particles.linksColor = void 0, this.linkContainer.particles.linksColors = new Map } interact(t) { if (!t.options.links) return; t.links = []; const e = t.getPosition(), i = this.container, s = i.canvas.size; if (e.x < 0 || e.y < 0 || e.x > s.width || e.y > s.height) return; const o = t.options.links, n = o.opacity, a = t.retina.linksDistance ?? 0, r = o.warp; let c; c = r ? new Qn(e.x, e.y, a, s) : new Ji(e.x, e.y, a); const l = i.particles.quadTree.query(c); for (const i of l) { const c = i.options.links; if (t === i || !c?.enable || o.id !== c.id || i.spawning || i.destroyed || !i.links || t.links.some((t => t.destination === i)) || i.links.some((e => e.destination === t))) continue; const l = i.getPosition(); if (l.x < 0 || l.y < 0 || l.x > s.width || l.y > s.height) continue; const h = Jn(e, l, a, s, r && c.warp); if (h > a) continue; const d = (1 - h / a) * n; this._setColor(t), t.links.push({ destination: i, opacity: d }) } } isEnabled(t) { return !!t.options.links?.enable } loadParticlesOptions(t, ...e) { t.links || (t.links = new Yn); for (const i of e) t.links.load(i?.links) } reset() { } } function ta(t, e) { const i = ((s = t.map((t => t.id))).sort(((t, e) => t - e)), s.join("_")); var s; let o = e.get(i); return void 0 === o && (o = I(), e.set(i, o)), o } class ea { constructor(t) { this.container = t, this._drawLinkLine = (t, e) => { const i = t.options.links; if (!i?.enable) return; const s = this.container, o = s.actualOptions, n = e.destination, a = t.getPosition(), r = n.getPosition(); let c = e.opacity; s.canvas.draw((e => { let l; const h = t.options.twinkle?.lines; if (h?.enable) { const t = h.frequency, e = Qt(h.color); I() < t && e && (l = e, c = U(h.opacity)) } if (!l) { const e = void 0 !== i.id ? s.particles.linksColors.get(i.id) : s.particles.linksColor; l = re(t, n, e) } if (!l) return; const d = t.retina.linksWidth ?? 0, u = t.retina.linksDistance ?? 0, { backgroundMask: p } = o; !function (t) { let e = !1; const { begin: i, end: s, maxDistance: o, context: n, canvasSize: a, width: r, backgroundMask: c, colorLine: l, opacity: h, links: d } = t; if (G(i, s) <= o) ve(n, i, s), e = !0; else if (d.warp) { let t, r; const c = $(i, { x: s.x - a.width, y: s.y }); if (c.distance <= o) { const e = i.y - c.dy / c.dx * i.x; t = { x: 0, y: e }, r = { x: a.width, y: e } } else { const e = $(i, { x: s.x, y: s.y - a.height }); if (e.distance <= o) { const s = -(i.y - e.dy / e.dx * i.x) / (e.dy / e.dx); t = { x: s, y: 0 }, r = { x: s, y: a.height } } else { const e = $(i, { x: s.x - a.width, y: s.y - a.height }); if (e.distance <= o) { const s = i.y - e.dy / e.dx * i.x; t = { x: -s / (e.dy / e.dx), y: s }, r = { x: t.x + a.width, y: t.y + a.height } } } } t && r && (ve(n, i, t), ve(n, s, r), e = !0) } if (!e) return; n.lineWidth = r, c.enable && (n.globalCompositeOperation = c.composite), n.strokeStyle = oe(l, h); const { shadow: u } = d; if (u.enable) { const t = Qt(u.color); t && (n.shadowBlur = u.blur, n.shadowColor = oe(t)) } n.stroke() }({ context: e, width: d, begin: a, end: r, maxDistance: u, canvasSize: s.canvas.size, links: i, backgroundMask: p, colorLine: l, opacity: c }) })) }, this._drawLinkTriangle = (t, e, i) => { const s = t.options.links; if (!s?.enable) return; const o = s.triangles; if (!o.enable) return; const n = this.container, a = n.actualOptions, r = e.destination, c = i.destination, l = o.opacity ?? .5 * (e.opacity + i.opacity); l <= 0 || n.canvas.draw((e => { const i = t.getPosition(), h = r.getPosition(), d = c.getPosition(), u = t.retina.linksDistance ?? 0; if (G(i, h) > u || G(d, h) > u || G(d, i) > u) return; let p = Qt(o.color); if (!p) { const e = void 0 !== s.id ? n.particles.linksColors.get(s.id) : n.particles.linksColor; p = re(t, r, e) } p && function (t) { const { context: e, pos1: i, pos2: s, pos3: o, backgroundMask: n, colorTriangle: a, opacityTriangle: r } = t; !function (t, e, i, s) { t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(i.x, i.y), t.lineTo(s.x, s.y), t.closePath() }(e, i, s, o), n.enable && (e.globalCompositeOperation = n.composite), e.fillStyle = oe(a, r), e.fill() }({ context: e, pos1: i, pos2: h, pos3: d, backgroundMask: a.backgroundMask, colorTriangle: p, opacityTriangle: l }) })) }, this._drawTriangles = (t, e, i, s) => { const o = i.destination; if (!t.links?.triangles.enable || !o.options.links?.triangles.enable) return; const n = o.links?.filter((t => { const e = this._getLinkFrequency(o, t.destination); return o.options.links && e <= o.options.links.frequency && s.findIndex((e => e.destination === t.destination)) >= 0 })); if (n?.length) for (const s of n) { const n = s.destination; this._getTriangleFrequency(e, o, n) > t.links.triangles.frequency || this._drawLinkTriangle(e, i, s) } }, this._getLinkFrequency = (t, e) => ta([t, e], this._freqs.links), this._getTriangleFrequency = (t, e, i) => ta([t, e, i], this._freqs.triangles), this._freqs = { links: new Map, triangles: new Map } } drawParticle(t, e) { const { links: i, options: s } = e; if (!i?.length) return; const o = i.filter((t => s.links && (s.links.frequency >= 1 || this._getLinkFrequency(e, t.destination) <= s.links.frequency))); for (const t of o) this._drawTriangles(s, e, t, o), t.opacity > 0 && (e.retina.linksWidth ?? 0) > 0 && this._drawLinkLine(e, t) } async init() { this._freqs.links = new Map, this._freqs.triangles = new Map, await Promise.resolve() } particleCreated(t) { if (t.links = [], !t.options.links) return; const e = this.container.retina.pixelRatio, { retina: i } = t, { distance: s, width: o } = t.options.links; i.linksDistance = s * e, i.linksWidth = o * e } particleDestroyed(t) { t.links = [] } } class ia { constructor() { this.id = "links" } getPlugin(t) { return Promise.resolve(new ea(t)) } loadOptions() { } needsPlugin() { return !0 } } class sa { draw(t) { const { particle: e, radius: i } = t; !function (t, e, i) { const { context: s } = t, o = i.count.numerator * i.count.denominator, n = i.count.numerator / i.count.denominator, a = 180 * (n - 2) / n, r = Math.PI - N(a); if (s) { s.beginPath(), s.translate(e.x, e.y), s.moveTo(0, 0); for (let t = 0; t < o; t++)s.lineTo(i.length, 0), s.translate(i.length, 0), s.rotate(r) } }(t, this.getCenter(e, i), this.getSidesData(e, i)) } getSidesCount(t) { const e = t.shapeData; return Math.round(U(e?.sides ?? 5)) } } class oa extends sa { constructor() { super(...arguments), this.validTypes = ["polygon"] } getCenter(t, e) { return { x: -e / (t.sides / 3.5), y: -e / .76 } } getSidesData(t, e) { const i = t.sides; return { count: { denominator: 1, numerator: i }, length: 2.66 * e / (i / 3) } } } class na extends sa { constructor() { super(...arguments), this.validTypes = ["triangle"] } getCenter(t, e) { return { x: -e, y: e / 1.66 } } getSidesCount() { return 3 } getSidesData(t, e) { return { count: { denominator: 2, numerator: 3 }, length: 2 * e } } } class aa { constructor() { this.enable = !1, this.speed = 0, this.decay = 0, this.sync = !1 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed && (this.speed = j(t.speed)), void 0 !== t.decay && (this.decay = j(t.decay)), void 0 !== t.sync && (this.sync = t.sync)) } } class ra extends ui { constructor() { super(), this.animation = new aa, this.direction = vs.clockwise, this.path = !1, this.value = 0 } load(t) { t && (super.load(t), void 0 !== t.direction && (this.direction = t.direction), this.animation.load(t.animation), void 0 !== t.path && (this.path = t.path)) } } const ca = 2 * Math.PI; class la { constructor(t) { this.container = t } init(t) { const e = t.options.rotate; if (!e) return; t.rotate = { enable: e.animation.enable, value: N(U(e.value)), min: 0, max: ca }, t.pathRotation = e.path; let i = e.direction; switch (i === vs.random && (i = Math.floor(2 * I()) > 0 ? vs.counterClockwise : vs.clockwise), i) { case vs.counterClockwise: case "counterClockwise": t.rotate.status = ot.decreasing; break; case vs.clockwise: t.rotate.status = ot.increasing }const s = e.animation; s.enable && (t.rotate.decay = 1 - U(s.decay), t.rotate.velocity = U(s.speed) / 360 * this.container.retina.reduceFactor, s.sync || (t.rotate.velocity *= I())), t.rotation = t.rotate.value } isEnabled(t) { const e = t.options.rotate; return !!e && !t.destroyed && !t.spawning && (!!e.value || e.animation.enable || e.path) } loadOptions(t, ...e) { t.rotate || (t.rotate = new ra); for (const i of e) t.rotate.load(i?.rotate) } update(t, e) { this.isEnabled(t) && (t.isRotating = !!t.rotate, t.rotate && (Ht(t, t.rotate, !1, nt.none, e), t.rotation = t.rotate.value)) } } const ha = Math.sqrt(2); class da { constructor() { this.validTypes = ["edge", "square"] } draw(t) { !function (t) { const { context: e, radius: i } = t, s = i / ha, o = 2 * s; e.rect(-s, -s, o, o) }(t) } getSidesCount() { return 4 } } class ua { constructor() { this.validTypes = ["star"] } draw(t) { !function (t) { const { context: e, particle: i, radius: s } = t, o = i.sides, n = i.starInset ?? 2; e.moveTo(0, 0 - s); for (let t = 0; t < o; t++)e.rotate(Math.PI / o), e.lineTo(0, 0 - s * n), e.rotate(Math.PI / o), e.lineTo(0, 0 - s) }(t) } getSidesCount(t) { const e = t.shapeData; return Math.round(U(e?.sides ?? 5)) } particleInit(t, e) { const i = e.shapeData; e.starInset = U(i?.inset ?? 2) } } class pa { constructor(t) { this.container = t } init(t) { const e = this.container, i = t.options, s = It(i.stroke, t.id, i.reduceDuplicates); t.strokeWidth = U(s.width) * e.retina.pixelRatio, t.strokeOpacity = U(s.opacity ?? 1), t.strokeAnimation = s.color?.animation; const o = Yt(s.color) ?? t.getFillColor(); o && (t.strokeColor = he(o, t.strokeAnimation, e.retina.reduceFactor)) } isEnabled(t) { const e = t.strokeAnimation, { strokeColor: i } = t; return !t.destroyed && !t.spawning && !!e && (void 0 !== i?.h.value && i.h.enable || void 0 !== i?.s.value && i.s.enable || void 0 !== i?.l.value && i.l.enable) } update(t, e) { this.isEnabled(t) && pe(t.strokeColor, e) } } async function fa(t, e = !0) { await async function (t, e = !0) { await t.addMover("parallax", (() => Promise.resolve(new Bn)), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalAttract", (e => Promise.resolve(new Ro(t, e))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalBounce", (t => Promise.resolve(new Ho(t))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalBubble", (t => Promise.resolve(new No(t))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalConnect", (t => Promise.resolve(new Ko(t))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalGrab", (t => Promise.resolve(new on(t))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalPause", (t => Promise.resolve(new nn(t))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalPush", (t => Promise.resolve(new rn(t))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalRemove", (t => Promise.resolve(new ln(t))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalRepulse", (e => Promise.resolve(new fn(t, e))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalSlow", (t => Promise.resolve(new vn(t))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("particlesAttract", (t => Promise.resolve(new qn(t))), e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("particlesCollisions", (t => Promise.resolve(new Nn(t))), e) }(t, !1), await async function (t, e = !0) { await async function (t, e = !0) { await t.addInteractor("particlesLinks", (async t => Promise.resolve(new Kn(t))), e) }(t, e), await async function (t, e = !0) { const i = new ia; await t.addPlugin(i, e) }(t, e) }(t, !1), await async function () { T(gs.easeInQuad, (t => t ** 2)), T(gs.easeOutQuad, (t => 1 - (1 - t) ** 2)), T(gs.easeInOutQuad, (t => t < .5 ? 2 * t ** 2 : 1 - (-2 * t + 2) ** 2 / 2)), await Promise.resolve() }(), await async function (t, e = !0) { await t.addShape(new So, e) }(t, !1), await async function (t, e = !0) { !function (t) { t.loadImage || (t.loadImage = async e => { if (!e.name && !e.src) throw new Error(`${f} no image source provided`); if (t.images || (t.images = []), !t.images.find((t => t.name === e.name || t.source === e.src))) try { const i = { gif: e.gif ?? !1, name: e.name ?? e.src, source: e.src, type: e.src.substring(e.src.length - En), error: !1, loading: !0, replaceColor: e.replaceColor, ratio: e.width && e.height ? e.width / e.height : void 0 }; let s; t.images.push(i), s = e.gif ? On : e.replaceColor ? bn : gn, await s(i) } catch { throw new Error(`${f} ${e.name ?? e.src} not found`) } }) }(t); const i = new Tn(t); await t.addPlugin(i, e), await t.addShape(new Sn(t), e) }(t, !1), await async function (t, e = !0) { await t.addShape(new Ln, e) }(t, !1), await async function (t, e = !0) { await async function (t, e = !0) { await t.addShape(new oa, e) }(t, e), await async function (t, e = !0) { await t.addShape(new na, e) }(t, e) }(t, !1), await async function (t, e = !0) { await t.addShape(new da, e) }(t, !1), await async function (t, e = !0) { await t.addShape(new ua, e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("life", (async t => Promise.resolve(new Fn(t))), e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("rotate", (t => Promise.resolve(new la(t))), e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("strokeColor", (t => Promise.resolve(new pa(t))), e) }(t, !1), await async function (t, e = !0) { await async function (t, e = !0) { await t.addMover("base", (() => Promise.resolve(new vo)), e) }(t, !1), await async function (t, e = !0) { await t.addShape(new go, e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("color", (t => Promise.resolve(new bo(t))), e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("opacity", (t => Promise.resolve(new wo(t))), e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("outModes", (t => Promise.resolve(new Co(t))), e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("size", (() => Promise.resolve(new Mo)), e) }(t, !1), await t.refresh(e) }(t, e) } function ma(t, e, i, s, o, n) { const a = { x: -e.length * i * .5, y: .5 * i }, r = 2 * i; n ? t.fillText(e, a.x, a.y + r * o) : t.strokeText(e, a.x, a.y + r * o) } class va { constructor() { this.validTypes = ["text", "character", "char", "multiline-text"] } draw(t) { !function (t) { const { context: e, particle: i, radius: s, opacity: o } = t, n = i.shapeData; if (!n) return; const a = n.value; if (void 0 === a) return; void 0 === i.text && (i.text = It(a, i.randomIndexData)); const r = i.text, c = n.style ?? "", l = n.weight ?? "400", h = 2 * Math.round(s), d = n.font ?? "Verdana", u = i.shapeFill, p = r?.split("\n"); if (p) { e.font = `${c} ${l} ${h}px "${d}"`, e.globalAlpha = o; for (let t = 0; t < p.length; t++)ma(e, p[t], s, 0, t, u); e.globalAlpha = 1 } }(t) } async init(t) { const e = t.actualOptions, { validTypes: i } = this; if (i.find((t => gt(t, e.particles.shape.type)))) { const t = i.map((t => e.particles.shape.options[t])).find((t => !!t)), s = []; Rt(t, (t => { s.push(bt(t.font, t.weight)) })), await Promise.all(s) } } particleInit(t, e) { if (!e.shape || !this.validTypes.includes(e.shape)) return; const i = e.shapeData; if (void 0 === i) return; const s = i.value; void 0 !== s && (e.text = It(s, e.randomIndexData)) } } var ya; !function (t) { t.clockwise = "clockwise", t.counterClockwise = "counter-clockwise", t.random = "random" }(ya || (ya = {})); class ga { constructor() { this.enable = !1, this.speed = 0, this.decay = 0, this.sync = !1 } load(t) { t && (void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed && (this.speed = j(t.speed)), void 0 !== t.decay && (this.decay = j(t.decay)), void 0 !== t.sync && (this.sync = t.sync)) } } class ba extends ui { constructor() { super(), this.animation = new ga, this.direction = ya.clockwise, this.enable = !1, this.value = 0 } load(t) { super.load(t), t && (this.animation.load(t.animation), void 0 !== t.direction && (this.direction = t.direction), void 0 !== t.enable && (this.enable = t.enable)) } } const wa = 2 * Math.PI; class xa { constructor(t) { this.container = t } getTransformValues(t) { const e = t.tilt?.enable && t.tilt; return { b: e ? Math.cos(e.value) * e.cosDirection : void 0, c: e ? Math.sin(e.value) * e.sinDirection : void 0 } } init(t) { const e = t.options.tilt; if (!e) return; t.tilt = { enable: e.enable, value: N(U(e.value)), sinDirection: I() >= v ? 1 : -1, cosDirection: I() >= v ? 1 : -1, min: 0, max: wa }; let i = e.direction; switch (i === ya.random && (i = Math.floor(2 * I()) > 0 ? ya.counterClockwise : ya.clockwise), i) { case ya.counterClockwise: case "counterClockwise": t.tilt.status = ot.decreasing; break; case ya.clockwise: t.tilt.status = ot.increasing }const s = t.options.tilt?.animation; s?.enable && (t.tilt.decay = 1 - U(s.decay), t.tilt.velocity = U(s.speed) / 360 * this.container.retina.reduceFactor, s.sync || (t.tilt.velocity *= I())) } isEnabled(t) { const e = t.options.tilt?.animation; return !t.destroyed && !t.spawning && !!e?.enable } loadOptions(t, ...e) { t.tilt || (t.tilt = new ba); for (const i of e) t.tilt.load(i?.tilt) } async update(t, e) { this.isEnabled(t) && t.tilt && (Ht(t, t.tilt, !1, nt.none, e), await Promise.resolve()) } } class _a { constructor() { this.enable = !1, this.frequency = .05, this.opacity = 1 } load(t) { t && (void 0 !== t.color && (this.color = Ve.create(this.color, t.color)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.frequency && (this.frequency = t.frequency), void 0 !== t.opacity && (this.opacity = j(t.opacity))) } } class ka { constructor() { this.lines = new _a, this.particles = new _a } load(t) { t && (this.lines.load(t.lines), this.particles.load(t.particles)) } } class Pa { getColorStyles(t, e, i, s) { const o = t.options.twinkle; if (!o) return {}; const n = o.particles, a = n.enable && I() < n.frequency, r = t.options.zIndex, c = (1 - t.zIndexFactor) ** r.opacityRate, l = a ? U(n.opacity) * c : s, h = Yt(n.color), d = h ? ne(h, l) : void 0, u = {}, p = a && d; return u.fill = p ? d : void 0, u.stroke = p ? d : void 0, u } async init() { await Promise.resolve() } isEnabled(t) { const e = t.options.twinkle; return !!e && e.particles.enable } loadOptions(t, ...e) { t.twinkle || (t.twinkle = new ka); for (const i of e) t.twinkle.load(i?.twinkle) } async update() { await Promise.resolve() } } class za { constructor() { this.angle = 50, this.move = 10 } load(t) { t && (void 0 !== t.angle && (this.angle = j(t.angle)), void 0 !== t.move && (this.move = j(t.move))) } } class Ca { constructor() { this.distance = 5, this.enable = !1, this.speed = new za } load(t) { if (t && (void 0 !== t.distance && (this.distance = j(t.distance)), void 0 !== t.enable && (this.enable = t.enable), void 0 !== t.speed)) if (x(t.speed)) this.speed.load({ angle: t.speed }); else { const e = t.speed; void 0 !== e.min ? this.speed.load({ angle: e }) : this.speed.load(t.speed) } } } const Ma = 2 * Math.PI, Oa = 2 * Math.PI; class Sa { constructor(t) { this.container = t } init(t) { const e = t.options.wobble; t.wobble = e?.enable ? { angle: I() * Oa, angleSpeed: U(e.speed.angle) / 360, moveSpeed: U(e.speed.move) / 10 } : { angle: 0, angleSpeed: 0, moveSpeed: 0 }, t.retina.wobbleDistance = U(e?.distance ?? 0) * this.container.retina.pixelRatio } isEnabled(t) { return !t.destroyed && !t.spawning && !!t.options.wobble?.enable } loadOptions(t, ...e) { t.wobble || (t.wobble = new Ca); for (const i of e) t.wobble.load(i?.wobble) } update(t, e) { this.isEnabled(t) && function (t, e) { const { wobble: i } = t.options, { wobble: s } = t; if (!i?.enable || !s) return; const o = s.angleSpeed * e.factor, n = s.moveSpeed * e.factor * ((t.retina.wobbleDistance ?? 0) * e.factor) / (y / 60), a = Ma, { position: r } = t; s.angle += o, s.angle > a && (s.angle -= a), r.x += n * Math.cos(s.angle), r.y += n * Math.abs(Math.sin(s.angle)) }(t, e) } } async function Da(t, e = !0) { await async function (t, e = !0) { await t.addParticleUpdater("destroy", (e => Promise.resolve(new qs(t, e))), e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("roll", (() => Promise.resolve(new mo)), e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("tilt", (t => Promise.resolve(new xa(t))), e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("twinkle", (() => Promise.resolve(new Pa)), e) }(t, !1), await async function (t, e = !0) { await t.addParticleUpdater("wobble", (t => Promise.resolve(new Sa(t))), e) }(t, !1), await async function (t, e = !0) { await t.addShape(new va, e) }(t, !1), await async function (t, e = !0) { await t.addInteractor("externalTrail", (t => Promise.resolve(new lo(t))), e) }(t, !1), await async function (t, e = !0) { await t.addPlugin(new Ts, e) }(t, !1), await async function (t, e = !0) { t.emitterShapeManager || (t.emitterShapeManager = new Js(t)), t.addEmitterShapeGenerator || (t.addEmitterShapeGenerator = (e, i) => { t.emitterShapeManager?.addShapeGenerator(e, i) }); const i = new Xs(t); await t.addPlugin(i, e) }(t, !1), await async function (t, e = !0) { const i = t; i.addEmitterShapeGenerator?.("circle", new io), await i.refresh(e) }(t, !1), await async function (t, e = !0) { const i = t; i.addEmitterShapeGenerator?.("square", new ao), await i.refresh(e) }(t, !1), await fa(t, e) } return e })())), function (e) { "use strict"; t.fn.particles = function () { var t = this, i = "tsparticles"; return { init: function (s, o) { t.each((function (t, n) { void 0 === n.id && (n.id = i + Math.floor(1e3 * e.getRandom())), e.tsParticles.load({ id: n.id, options: s }).then(o) })) }, ajax: function (s, o) { t.each((function (t, n) { void 0 === n.id && (n.id = i + Math.floor(1e3 * e.getRandom())), e.tsParticles.load({ id: n.id, url: s }).then(o) })) } } } }(window), t(window).on("elementor/frontend/init", (function () { null != window.paParticlesHandler && new paParticlesHandler("page", t(".elementor-page"), {}).init(); elementorFrontend.hooks.addAction("frontend/element_ready/global", (function (t, i) { if (t.hasClass("premium-particles-yes")) if (i(".particles-instant").length > 0) e(t); else { var s = new IntersectionObserver((function (i) { i.forEach((function (i) { i.isIntersecting && (e(t), s.unobserve(i.target)) })) })); s.observe(t[0]) } })) })), window.paParticlesHandler = function (e, i, s) { var o = this, n = {}; this.isAddonEnabled = !1, o.init = function () { this.isEditMode = elementorFrontend.isEditMode(), this.isEditMode && (this.initAddonSwListener(), this.initCustomCss(), this.initZIndex(), this.initApplyOn()), o.initParticles() }, o.initZIndex = function () { elementor.settings.page.addChangeCallback("premium_particles_zindex", o.onAddonZIndexChange) }, o.initApplyOn = function () { elementor.settings.page.addChangeCallback("premium_particles_responsive", o.onAddonApplyOnChange) }, o.initCustomCss = function () { elementor.settings.page.addChangeCallback("premium_particles_custom_style", o.onAddonCustomCssChange) }, o.initAddonSwListener = function () { elementor.settings.page.addChangeCallback("premium_particles_switcher", o.onAddonSwitcherChange) }, o.onAddonSwitcherChange = function (t) { "yes" === t ? o.initParticles() : o.destroy() }, o.onAddonApplyOnChange = function (t) { currentDevice = elementorFrontend.getCurrentDeviceMode(), -1 < t.indexOf(currentDevice) ? o.initParticles() : o.destroy() }, o.onAddonCustomCssChange = function (t) { "" !== t ? o.initParticles() : o.destroy() }, o.onAddonZIndexChange = function (t) { "" !== t ? o.initParticles() : o.destroy() }, o.destroy = function () { i.removeClass("premium-particles-yes premium-particles"), t(".premium-global-particles-" + o.getPageId()).remove() }, o.initParticles = async function () { var e = elementorFrontend.isEditMode() ? elementor.settings.page.model.attributes : elementorFrontend.config.settings.page; if (n = Object.assign({}, e), Object.keys(n).length && (o.isPgParticlesEnabled(), this.isAddonEnabled)) { o.generateParticles(); var s = n.premium_particles_custom_style, a = n.premium_particles_zindex, r = n.premium_particles_responsive; if (!s) return !1; var c = {}; c.style = JSON.parse(s), c.zindex = a, c.devices = r, c = Object.assign(c); var l = elementorFrontend.getCurrentDeviceMode(); if (-1 !== r.indexOf(l) || -1 === ["desktop", "mobile", "tablet"].indexOf(l)) { var h = i.find(".premium-global-particles"); return await loadFull(tsParticles), h.attr("id", "premium-section-particles"), t("#premium-section-particles").particles().init(c.style), h.children("canvas").css({ zIndex: c.zindex }), c } } }, o.isPgParticlesEnabled = function () { var t = "yes" === n.premium_particles_switcher; o.isAddonEnabled = !!t }, o.generateParticles = function () { var t = "premium-global-particles-" + o.getPageId(), e = o.getParticlesHtml(t); o.addParticles(t, e) }, o.getPageId = function () { return elementorFrontend.config.post.id }, o.getParticlesHtml = function (t) { var e = '<div class="premium-global-particles ' + t + '">'; return e += "</div>" }, o.addParticles = function (t, e) { o.addParticlesClasses(), i.find("." + t).remove(), i.prepend(e) }, o.addParticlesClasses = function () { i.removeClass((function (t, e) { return (e.match(new RegExp("(^|\\s)premium-particles-\\S+", "g")) || []).join(" ") })), i.addClass("premium-particles-yes premium-particles") } } }(jQuery);